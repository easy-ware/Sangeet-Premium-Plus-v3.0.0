<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Enhanced Music Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="icon" type="image/gif" href="/data/download/icons/sangeet-home" sizes="any">
  <link href="/design/index" rel="stylesheet">
  <link href="/design/report-issues" rel="stylesheet">
  <style>
    .ripple {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      /* Semi-transparent white, adjust color as needed */
      transform: scale(0);
      animation: ripple-animation 0.6s linear;
      pointer-events: none;
      /* Ensures the ripple doesnâ€™t interfere with clicks */
    }

    @keyframes ripple-animation {
      to {
        transform: scale(4);
        /* Expands the circle */
        opacity: 0;
        /* Fades out smoothly */
      }
    }
  </style>
  <style id="version-info">
    @keyframes float {

      0%,
      100% {
        transform: translateY(0) rotate(0deg);
      }

      50% {
        transform: translateY(-20px) rotate(10deg);
      }
    }

    @keyframes twinkle {

      0%,
      100% {
        opacity: 0;
      }

      50% {
        opacity: 1;
      }
    }

    .music-note {
      position: absolute;
      font-size: 24px;
      pointer-events: none;
      animation: float 3s infinite, twinkle 3s infinite;
    }
  </style>
  <style>
    .glass-button {
      position: relative;
      padding: 16px 32px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: all 0.3s ease;
      overflow: hidden;
      text-decoration: none;
      /* Added to remove underline from anchor */
    }

    .glass-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    }

    .glass-button:active {
      transform: translateY(0px);
    }

    .button-text {
      color: #2a2a2a;
      font-family: system-ui, -apple-system, sans-serif;
      font-weight: 500;
      font-size: 18px;
      z-index: 1;
    }

    .source-icon {
      width: 24px;
      height: 24px;
      animation: bounce 2s infinite;
    }

    .sparkle {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: #fff;
      animation: sparkle 1.5s infinite;
    }

    @keyframes bounce {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-4px);
      }
    }

    @keyframes sparkle {
      0% {
        transform: scale(0) rotate(0deg);
        opacity: 0;
      }

      50% {
        transform: scale(1) rotate(180deg);
        opacity: 1;
      }

      100% {
        transform: scale(0) rotate(360deg);
        opacity: 0;
      }
    }
  </style>
  <style>
    /* Playlist Header */
    .pl-header {
      display: flex;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Back Button */
    .pl-back-btn {
      background: none;
      border: none;
      color: var(--primary-light);
      cursor: pointer;
      margin-right: 1rem;
    }

    .pl-back-btn:hover {
      color: var(--accent-color);
    }

    /* Enhanced Song Item */
    .pl-song-item {
      display: flex;
      align-items: center;
      padding: 0.5rem;
      background: var(--surface-color);
      border-radius: 4px;
      margin-bottom: 0.3rem;
    }

    .pl-song-item:hover {
      background: var(--card-color);
    }

    /* Song Thumbnail */
    .pl-song-thumb {
      width: 50px;
      height: 50px;
      object-fit: cover;
      border-radius: 4px;
      margin-right: 1rem;
    }

    /* Song Information */
    .pl-song-info {
      flex-grow: 1;
    }

    .pl-song-title {
      font-weight: 500;
      color: var(--text-primary);
    }

    .pl-song-artist {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    /* Control Buttons */
    .pl-control-btn {
      background: none;
      border: none;
      color: var(--primary-light);
      cursor: pointer;
      padding: 0.5rem;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .pl-song-item:hover .pl-control-btn {
      opacity: 1;
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Enhanced Search Section -->
    <div class="search-container" style="top:3rem;">
      <input type="text" class="search-input" id="searchInput" placeholder="Search for songs or tap mic to speak..." />
      <div class="search-icons">
        <span class="material-icons search-icon" id="micIcon">mic</span>
        <span class="material-icons search-icon broom-icon" id="broomIcon">cleaning_services</span>
      </div>
    </div>

    <!-- Insights Modal Section -->
    <div class="insights-modal" id="insightsModal">
      <div class="insights-content">
        <div class="insights-header">
          <h2>Listening Insights</h2>
          <button class="close-button" id="closeInsights">
            <span class="material-icons">close</span>
          </button>
        </div>

        <div class="insights-body">
          <!-- Overview Insight Section -->
          <section class="insight-section">
            <h3>Overview</h3>
            <div class="stats-grid">
              <div class="stat-card">
                <span class="material-icons">schedule</span>
                <div class="stat-value" id="totalListeningTime">0h</div>
                <div class="stat-label">Total Time</div>
              </div>
              <div class="stat-card">
                <span class="material-icons">music_note</span>
                <div class="stat-value" id="totalSongs">0</div>
                <div class="stat-label">Songs Played</div>
              </div>
              <div class="stat-card">
                <span class="material-icons">group</span>
                <div class="stat-value" id="uniqueArtists">0</div>
                <div class="stat-label">Artists</div>
              </div>
              <div class="stat-card">
                <span class="material-icons">trending_up</span>
                <div class="stat-value" id="averageDaily">0</div>
                <div class="stat-label">Daily Average</div>
              </div>
            </div>
          </section>

          <!-- Top Artists Insight Section -->
          <section class="insight-section">
            <h3>Top Artists</h3>
            <div class="top-artists-list" id="topArtistsList"></div>
          </section>

          <!-- Listening Patterns Insight Section -->
          <section class="insight-section">
            <h3>Listening Patterns</h3>
            <div class="patterns-container">
              <div class="pattern-chart">
                <h4>Daily Activity</h4>
                <div id="dailyPatternChart"></div>
              </div>
              <div class="pattern-chart">
                <h4>Hourly Activity</h4>
                <div id="hourlyPatternChart"></div>
              </div>
            </div>
          </section>

          <!-- Recent Activity Insight Section -->
          <section class="insight-section">
            <h3>Recent Activity</h3>
            <div class="recent-activity-list" id="recentActivityList"></div>
          </section>


        </div>
      </div>
    </div>

    <!-- Results Grid Section -->
    <div class="results-container" id="resultsContainer"></div>

    <!-- Infinite Loader Section -->
    <div id="infiniteLoader" style="text-align:center; color:var(--text-secondary); display:none;">
      Loading more...
    </div>
  </div>

  <!-- Mini Player Section -->
  <div class="mini-player hidden" id="miniPlayer">
    <div class="mini-player-info">
      <img src="" alt="Cover" class="mini-player-thumb" id="miniPlayerThumb" />
      <div class="mini-player-text">
        <div class="mini-player-title" id="miniPlayerTitle">Title</div>
        <div class="mini-player-artist" id="miniPlayerArtist">Artist</div>
      </div>
    </div>

    <div class="player-controls">
      <button class="control-button" id="prevButton">
        <span class="material-icons">skip_previous</span>
      </button>
      <button class="control-button play-pause" id="playButton">
        <span class="material-icons">play_circle</span>
      </button>
      <button class="control-button" id="nextButton">
        <span class="material-icons">skip_next</span>
      </button>
    </div>

    <div class="progress-container" id="progressContainer">
      <div class="progress-bar">
        <div class="progress" id="progressBar"></div>
        <div class="progress-skeleton" id="progressSkeleton"></div>
        <div class="progress-hover" id="progressHover"></div>
      </div>
      <div class="time-indicator">
        <span id="currentTime">0:00</span>
        <span id="totalTime">0:00</span>
      </div>
    </div>

    <div class="volume-control">
      <button class="control-button" id="volumeButton">
        <span class="material-icons">volume_up</span>
      </button>
      <input type="range" class="volume-slider" min="0" max="100" value="100" id="volumeSlider" />
    </div>

    <button class="control-button expand" id="expandButton">
      <span class="material-icons">expand_less</span>
    </button>
  </div>

  <!-- Enhanced Full Player Section -->
  <div class="full-player" id="fullPlayer">
    <div class="full-player-header">
      <button class="control-button" id="minimizeButton" style="right:2rem; top:1.3rem; position: absolute; ">
        <span class="material-icons">expand_more</span>
      </button>
    </div>

    <div class="full-player-content">
      <div class="full-player-main">
        <div class="full-player-art">
          <img src="" alt="Cover" id="fullPlayerArt">
        </div>

        <div class="full-player-info">
          <div class="marquee">
            <div class="text" id="fullPlayerTitle">Choose a song to play</div>
          </div>
          <div class="full-player-artist" id="fullPlayerArtist">-</div>

          <div class="player-controls">
            <button class="control-button" id="fullPrevButton">
              <span class="material-icons">skip_previous</span>
            </button>
            <button class="control-button play-pause" id="fullPlayButton">
              <span class="material-icons">play_arrow</span>
            </button>
            <button class="control-button" id="fullNextButton">
              <span class="material-icons">skip_next</span>
            </button>
            <!-- Add to Playlist Button -->
            <button class="control-button" id="addToPlaylistButton" title="Add to Playlist">
              <span class="material-icons">playlist_add</span>
            </button>
          </div>

          <div class="progress-container" id="fullProgressContainer">
            <div class="progress-bar">
              <div class="progress" id="fullProgressBar"></div>
              <div class="progress-hover" id="fullProgressHover"></div>
            </div>
            <div class="time-indicator">
              <span id="fullCurrentTime">0:00</span>
              <span id="fullTotalTime">0:00</span>
            </div>
          </div>
        </div>
      </div>

      <div class="lyrics-container" id="lyricsContainer">
        <div class="lyrics-line">Choose a song to see lyrics</div>
      </div>
      <div class="artist-info-container">
        <img src="" alt="Artist" class="artist-image" id="artistImage">
        <div class="artist-details">
          <div class="artist-name" id="artistName">Artist Name</div>
          <div class="artist-year" id="artistYear">Year: -</div>
          <div class="artist-genre" id="artistGenre">Genre: -</div>
        </div>
      </div>

      <div class="artist-overview-container">
        <div class="artist-overview-header">
          <h3>Artist Overview</h3>
        </div>

        <div class="artist-description">
          <h4>About</h4>
          <p id="artistDescription">Loading artist details...</p>
        </div>

        <div class="artist-stats">
          <div class="stat-card">
            <span class="material-icons">group</span>
            <div class="stat-value" id="artistSubscribers">-</div>
            <div class="stat-label">Subscribers</div>
          </div>
          <div class="stat-card">
            <span class="material-icons">visibility</span>
            <div class="stat-value" id="artistViews">-</div>
            <div class="stat-label">Total Views</div>
          </div>
          <div class="stat-card">
            <span class="material-icons">headphones</span>
            <div class="stat-value" id="artistMonthlyListeners">-</div>
            <div class="stat-label">Monthly Listeners</div>
          </div>
        </div>

        <div class="artist-top-songs">
          <h4>Popular Songs</h4>
          <div class="top-songs-list" id="topSongsList">
            <!-- Songs will be populated here -->
          </div>
        </div>

        <div class="artist-links" id="artistLinks">
          <!-- Links will be added here -->
        </div>
      </div>
    </div>

    <!-- Integration Container Section -->
    <div class="integration-container" id="integrationContainer" style="display: none;">
      <div class="integration-header">
        <h3 class="text-lg font-bold mb-4">Integrate this Song</h3>
        <button class="close-button" id="closeIntegration">
          <span class="material-icons">close</span>
        </button>
      </div>

      <div class="integration-options">
        <div class="integration-sizes">
          <label class="text-sm text-gray-300 mb-2">Choose Size:</label>
          <div class="size-buttons">
            <button class="size-btn active" data-size="small">Small</button>
            <button class="size-btn" data-size="normal">Normal</button>
            <button class="size-btn" data-size="large">Large</button>
          </div>
        </div>

        <div class="integration-themes">
          <label class="text-sm text-gray-300 mb-2">Choose Theme:</label>
          <div class="theme-buttons">
            <button class="theme-btn active" data-theme="default">
              <span class="theme-color default"></span>
              Default
            </button>
            <button class="theme-btn" data-theme="purple">
              <span class="theme-color purple"></span>
              Purple
            </button>
            <button class="theme-btn" data-theme="blue">
              <span class="theme-color blue"></span>
              Blue
            </button>
            <button class="theme-btn" data-theme="dark">
              <span class="theme-color dark"></span>
              Dark
            </button>
          </div>
        </div>

        <div class="integration-preview">
          <label class="text-sm text-gray-300 mb-2">Preview:</label>
          <div class="preview-container" id="previewContainer">
            <iframe id="previewFrame" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe>
          </div>
        </div>

        <div class="integration-code">
          <label class="text-sm text-gray-300 mb-2">Embed Code:</label>
          <div class="code-container">
            <pre id="embedCode" class="code-block"></pre>
            <button class="copy-btn" id="copyCode">
              <span class="material-icons">content_copy</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>


  <!-- History Modal Section -->
  <div id="historyModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Listening History</h2>
        <button class="close-button" id="closeHistory">
          <span class="material-icons">close</span>
        </button>
      </div>
      <div class="modal-body">
        <div id="historyList" class="history-list"></div>
      </div>
    </div>
  </div>
  <div id="playlistModal" class="modal">
    <div class="modal-content">
      <span class="close-button">&times;</span>
      <h2 id="modalHeader">Playlists</h2>
      <div id="createPlaylistSection" style="display: none;">
        <!-- <input type="text" id="newPlaylistName" placeholder="Enter playlist name"> -->
        <input type="text" id="newPlaylistName" placeholder="Enter playlist name"
          style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; outline: none; width: 200px;">
        <button id="submitPlaylistBtn">Create</button>
        <button id="cancelPlaylistBtn">Cancel</button>
      </div>
      <button id="createPlaylistBtn">Create New Playlist</button>
      <div id="playlistList">
        <!-- Playlist items or songs will be inserted here dynamically -->
      </div>
    </div>
  </div>

  <div class="http-warning-overlay" id="httpWarningOverlay">
    <div class="http-warning-widget">
      <div class="http-warning-title">Features Warning</div>
      <div class="http-warning-message">
        You're accessing this page via HTTP. Some features, like share and musch more, are unavailable without HTTPS.
      </div>
      <div class="http-warning-recommendation" id="httpWarningRecommendation">
        Please use HTTPS for the best experience. Access via a secure domain or contact your admin for secure access.
      </div>
      <button class="http-warning-close" id="httpWarningClose">
        <span class="material-icons">close</span>
      </button>
    </div>
  </div>


  <!-- Hidden Audio Element -->
  <audio id="audioElement" preload="auto"></audio>


  <script>


    /**
     * Global state management
     * Handles all dynamic data for the player including:
     * - Current playback state
     * - Queue management
     * - Search state
     * - Volume settings
     */
    const state = {
      currentSongId: null,        // Currently playing/selected song ID
      recommendationsLoading: false, // Flag for recommendation loading state
      maxQueueSize: 50,          // Maximum songs in queue
      isPlaying: false,          // Current playback state
      queue: [],                 // Song queue array
      queueIndex: -1,            // Current position in queue
      volume: localStorage.getItem("player-volume") || 100, // Playback volume (0-100)
      searchQuery: "",           // Current search query
      searchPage: 0,             // Current page for infinite scroll
      searchLimit: 20,           // Items per page
      searchHasMore: true,       // Flag for more results available
      loadingMore: false,        // Flag for loading state
      displayedItems: new Set()  // Track displayed songs to prevent duplicates
    };


    /**
     * DOM Elements
     * Centralized access to all DOM elements used by the player
     * Grouped by functionality for better organization
     */
    const E = {
      // Search Related Elements
      searchInput: document.getElementById("searchInput"),
      broomIcon: document.getElementById("broomIcon"),
      micIcon: document.getElementById("micIcon"),
      resultsContainer: document.getElementById("resultsContainer"),
      infiniteLoader: document.getElementById("infiniteLoader"),

      // Mini Player Elements
      miniPlayer: document.getElementById("miniPlayer"),
      miniPlayerThumb: document.getElementById("miniPlayerThumb"),
      miniPlayerTitle: document.getElementById("miniPlayerTitle"),
      miniPlayerArtist: document.getElementById("miniPlayerArtist"),
      playButton: document.getElementById("playButton"),
      prevButton: document.getElementById("prevButton"),
      nextButton: document.getElementById("nextButton"),

      // Progress Elements
      progressBar: document.getElementById("progressBar"),
      progressSkeleton: document.getElementById("progressSkeleton"),
      progressContainer: document.getElementById("progressContainer"),
      progressHover: document.getElementById("progressHover"),
      currentTime: document.getElementById("currentTime"),
      totalTime: document.getElementById("totalTime"),

      // Volume Elements
      volumeSlider: document.getElementById("volumeSlider"),
      volumeButton: document.getElementById("volumeButton"),

      // Full Player Elements
      expandButton: document.getElementById("expandButton"),
      minimizeButton: document.getElementById("minimizeButton"),
      fullPlayer: document.getElementById("fullPlayer"),
      fullPlayerArt: document.getElementById("fullPlayerArt"),
      fullPlayerTitle: document.getElementById("fullPlayerTitle"),
      fullPlayerArtist: document.getElementById("fullPlayerArtist"),

      // Content Elements
      lyricsContainer: document.getElementById("lyricsContainer"),
      artistImage: document.getElementById("artistImage"),
      artistName: document.getElementById("artistName"),
      artistYear: document.getElementById("artistYear"),
      artistGenre: document.getElementById("artistGenre"),

      // Full Player Controls
      fullPlayButton: document.getElementById("fullPlayButton"),
      fullPrevButton: document.getElementById("fullPrevButton"),
      fullNextButton: document.getElementById("fullNextButton"),
      fullProgressBar: document.getElementById("fullProgressBar"),
      fullProgressContainer: document.getElementById("fullProgressContainer"),
      fullProgressHover: document.getElementById("fullProgressHover"),
      fullCurrentTime: document.getElementById("fullCurrentTime"),
      fullTotalTime: document.getElementById("fullTotalTime"),

      // Audio Element
      audio: document.getElementById("audioElement")
    };

    /**
     * Core Utility Functions
     * Basic helper functions used throughout the application
     */

    /**
     * Format time in seconds to MM:SS format
     * @param {number} sec - Time in seconds
     * @returns {string} Formatted time string
     */


    /**
     * Debounce function for search input
     * @param {Function} fn - Function to debounce
     * @param {number} delay - Delay in milliseconds
     */
    function debounce(fn, delay) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), delay);
      };
    }

    /**
     * Show toast notification
     * @param {string} message - Message to display
     */
    function showToast(message, type = 'info') {
      // const toast = document.createElement('div');
      // toast.className = 'toast-notification';
      // toast.textContent = message;
      // document.body.appendChild(toast);
      // setTimeout(() => toast.remove(), 3000);
      showNotification(type, 'Sangeet Premium Plus', message, 4000);
    }

    /**
     * Initial styles setup
     * Add required styles for toast notifications and controls
     */
    const additionalStyles = document.createElement('style');
    additionalStyles.textContent = `
  .toast-notification {
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 12px 24px;
    border-radius: 24px;
    font-size: 14px;
    z-index: 1000;
    animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
  }

  @keyframes toastIn {
    from { opacity: 0; transform: translate(-50%, 20px); }
    to { opacity: 1; transform: translate(-50%, 0); }
  }

  @keyframes toastOut {
    from { opacity: 1; transform: translate(-50%, 0); }
    to { opacity: 0; transform: translate(-50%, 20px); }
  }

  .additional-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    border-left: 1px solid rgba(255,255,255,0.1);
    padding-left: 1rem;
    margin-left: 0.5rem;
  }

  .full-player .additional-controls {
    border: none;
    padding-left: 0;
    margin-left: 1rem;
  }

  @media (max-width: 768px) {
    .additional-controls {
      border: none;
      padding-left: 0;
    }
  }
`;
    document.head.appendChild(additionalStyles);
    /**
     * Enhanced Music Player - Complete JavaScript Implementation
     * =======================================================
     *
     * PART 2: Speech Recognition & Player Controls
     */

    /**
     * Speech Recognition Setup
     * Handles voice search functionality
     */
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = SpeechRecognition ? new SpeechRecognition() : null;

    function setupSpeechRecognition() {
      if (!recognition) {
        E.micIcon.style.display = 'none';
        return;
      }

      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      let isListening = false;
      let wasPlaying = false; // Tracks if audio was playing before STT

      function startListening() {
        try {
          isListening = true;
          E.micIcon.textContent = 'mic';
          E.micIcon.classList.add('listening');
          E.micIcon.style.color = 'var(--primary-light)';
          E.searchInput.placeholder = 'Listening...';

          // Pause audio if itâ€™s playing
          if (E.audio && !E.audio.paused) {
            wasPlaying = true;
            E.audio.pause();
          } else {
            wasPlaying = false;
          }

          recognition.start();
        } catch (err) {
          console.error('Speech recognition start error:', err);
          stopListening();
        }
      }

      function stopListening() {
        isListening = false;
        E.micIcon.classList.remove('listening');
        E.micIcon.style.color = '';
        E.micIcon.textContent = 'mic';
        E.searchInput.placeholder = 'Search for songs or tap mic to speak...';

        // Resume audio if it was playing
        if (wasPlaying && E.audio.paused) {
          E.audio.play().catch(error => {
            console.error('Error resuming playback:', error);
            showToast('Failed to resume playback', 'error');
          });
        }
        wasPlaying = false; // Reset the flag

        try {
          recognition.stop();
        } catch (err) {
          console.error('Speech recognition stop error:', err);
        }
      }

      // Speech Recognition Event Handlers
      recognition.onstart = () => {
        isListening = true;
        E.micIcon.textContent = 'mic';
        E.micIcon.classList.add('listening');
      };

      recognition.onend = () => {
        stopListening();
      };

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        E.searchInput.value = transcript;
        E.searchInput.dispatchEvent(new Event('input'));

        E.micIcon.textContent = 'done';
        setTimeout(() => {
          E.micIcon.textContent = 'mic';
        }, 1000);
      };

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        E.micIcon.textContent = 'mic_off';
        let errorMessage;
        switch (event.error) {
          case 'network':
            errorMessage = 'Network error: Please check your internet connection.';
            break;
          case 'no-speech':
            errorMessage = 'No speech detected. Please try again.';
            break;
          case 'not-allowed':
            errorMessage = 'Permission denied. Ensure the page is served over HTTPS or localhost.';
            break;
          default:
            errorMessage = 'An error occurred during speech recognition.';
        }
        showToast(errorMessage, 'error');
        setTimeout(() => {
          stopListening();
        }, 1000);
      };

      // Mic Icon Event Listeners
      E.micIcon.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        isListening ? stopListening() : startListening();
      });

      E.micIcon.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        isListening ? stopListening() : startListening();
      });
    }

    /**
     * Player Controls Setup
     * Handles all player control buttons and functionality
     */

    // Define control button templates
    const additionalControls = `
<div class="additional-controls">
  <button class="control-button" id="downloadButton" title="Download song">
    <span class="material-icons">download</span>
  </button>
  <button class="control-button" id="shareButton" title="Share song">
    <span class="material-icons">share</span>
  </button>
</div>
`;

    const fullPlayerControls = `
<div class="additional-controls">
  <button class="control-button" id="fullDownloadButton" title="Download song">
    <span class="material-icons">download</span>
  </button>
  <button class="control-button" id="fullShareButton" title="Share song">
    <span class="material-icons">share</span>
  </button>
</div>
`;

    /**
     * Initialize Player Controls
     * Sets up all control buttons and their event handlers
     */
    function initializePlayerControls() {
      // Add controls to players
      document.querySelector('.volume-control').insertAdjacentHTML('afterend', additionalControls);
      document.querySelector('.full-player .player-controls').insertAdjacentHTML('beforeend', fullPlayerControls);



      const controls = {
        share: {
          mini: document.getElementById('shareButton'),
          full: document.getElementById('fullShareButton')
        },
        download: {
          mini: document.getElementById('downloadButton'),
          full: document.getElementById('fullDownloadButton')
        }
      };

      /**
       * Handle song sharing
       * Provides native share or fallback to clipboard copy
       */
      async function handleShare() {
        if (!state.currentSongId) return;

        const shareUrl = `${window.location.origin}/share/open/${state.currentSongId}`;
        const songTitle = `${E.miniPlayerTitle.textContent} - ${E.miniPlayerArtist.textContent}`;

        try {
          if (navigator.share) {
            await navigator.share({
              title: songTitle,
              text: 'Check out this song!',
              url: shareUrl
            });
          } else {
            await navigator.clipboard.writeText(shareUrl);
            Object.values(controls.share).forEach(btn => {
              if (btn) {
                const icon = btn.querySelector('.material-icons');
                icon.textContent = 'check';
                setTimeout(() => icon.textContent = 'share', 2000);
              }
            });
            showToast('Share link copied to clipboard!');
          }
        } catch (err) {
          console.error('Share failed:', err);
        }
      }

      /**
       * Handle song download
       * Downloads current song and shows feedback
       */
      async function handleDownload() {
        if (!state.currentSongId) return;

        try {
          // Update button states
          Object.values(controls.download).forEach(btn => {
            if (btn) {
              const icon = btn.querySelector('.material-icons');
              icon.textContent = 'cloud_download';
            }
          });

          // Trigger download
          const link = document.createElement('a');
          link.href = `/api/download/${state.currentSongId}`;
          link.style.display = 'none';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          // Show success
          Object.values(controls.download).forEach(btn => {
            if (btn) {
              const icon = btn.querySelector('.material-icons');
              icon.textContent = 'cloud_done';
              setTimeout(() => icon.textContent = 'download', 2000);
            }
          });

        } catch (error) {
          console.error('Download error:', error);
          // Show error
          Object.values(controls.download).forEach(btn => {
            if (btn) {
              const icon = btn.querySelector('.material-icons');
              icon.textContent = 'cloud_off';
              setTimeout(() => icon.textContent = 'download', 2000);
            }
          });
          showToast('Download failed. Please try again.');
        }
      }

      // Attach event listeners to all controls
      Object.values(controls.share).forEach(btn => {
        btn?.addEventListener('click', handleShare);
      });

      Object.values(controls.download).forEach(btn => {
        btn?.addEventListener('click', handleDownload);
      });
    }

    /**
     * Volume Control Functions
     * Handles volume slider and mute functionality
     */
    function handleVolumeChange(e) {
      state.volume = e.target.value;
      localStorage.setItem("player-volume", state.volume);
      E.audio.volume = state.volume / 100;
      updateVolumeIcon(state.volume);
    }

    function toggleMute() {
      if (E.audio.volume > 0) {
        E.volumeSlider.dataset.lastVol = state.volume;
        E.volumeSlider.value = 0;
        state.volume = 0;
      } else {
        const lastVol = E.volumeSlider.dataset.lastVol || 100;
        E.volumeSlider.value = lastVol;
        state.volume = lastVol;
      }
      E.volumeSlider.dispatchEvent(new Event("input"));
    }

    function updateVolumeIcon(volume) {
      const icon = E.volumeButton.querySelector(".material-icons");
      if (volume == 0) icon.textContent = "volume_off";
      else if (volume < 50) icon.textContent = "volume_down";
      else icon.textContent = "volume_up";
    }
    /**
     * Enhanced Music Player - Complete JavaScript Implementation
     * =======================================================
     *
     * PART 3: Media Playback & Progress Tracking
     */

    /**
     * Progress Bar Setup
     * Handles progress bar interaction and display
     */
    function setupProgressBar(container, progressHover, callback) {
      if (!container || !progressHover) return;

      let isDragging = false;

      container.addEventListener("mousemove", (e) => {
        const rect = container.getBoundingClientRect();
        const percent = ((e.clientX - rect.left) / rect.width) * 100;
        progressHover.style.width = `${percent}%`;

        if (isDragging && E.audio.duration) {
          E.audio.currentTime = E.audio.duration * (percent / 100);
        }
      });

      container.addEventListener("mouseleave", () => {
        progressHover.style.width = "0%";
      });

      container.addEventListener("mousedown", () => {
        isDragging = true;
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
      });

      container.addEventListener("click", (e) => {
        const rect = container.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
          if (callback) callback(percent);
        }
      });

      // Touch support
      container.addEventListener("touchstart", (e) => {
        e.preventDefault();
        isDragging = true;
      });

      container.addEventListener("touchmove", (e) => {
        if (!isDragging) return;
        const touch = e.touches[0];
        const rect = container.getBoundingClientRect();
        const percent = ((touch.clientX - rect.left) / rect.width) * 100;
        progressHover.style.width = `${percent}%`;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * (percent / 100);
        }
      });

      container.addEventListener("touchend", () => {
        isDragging = false;
      });
    }


    /**
     * Toggle play/pause state
     */
    // Add these functions to your JavaScript where you handle audio playback

    // Track loading state
    let isAudioLoading = false;
    let playAfterLoad = false;

    // Enhanced audio initialization
    function initializeAudio() {
      const audioElement = document.getElementById('audioElement');

      // Loading states
      audioElement.addEventListener('loadstart', () => {
        isAudioLoading = true;
        console.log('Audio loading started');
      });

      audioElement.addEventListener('canplay', () => {
        isAudioLoading = false;
        console.log('Audio can play');
        if (playAfterLoad) {
          playAfterLoad = false;
          playAudioSafely();
        }
      });

      // Error handling
      audioElement.addEventListener('error', (e) => {
        isAudioLoading = false;
        playAfterLoad = false;
        console.error('Audio error:', e);
      });

      // Abort handling
      audioElement.addEventListener('abort', () => {
        isAudioLoading = false;
        playAfterLoad = false;
        console.log('Audio loading aborted');
      });
    }


    //     async function loadAndPlay(songId) {
    //     if (songId === state.currentSongId) {
    //         togglePlay();
    //         return;
    //     }

    //     state.currentSongId = songId;
    //     E.miniPlayer.classList.remove("hidden");

    //     resetPlayerUI();
    //     E.progressSkeleton.style.opacity = "1";

    //     try {
    //         isAudioLoading = true;
    //         playAfterLoad = true;

    //         // Fetch song info from backend
    //         const infoResponse = await fetch(`/api/song-info/${songId}`);
    //         const infoData = await infoResponse.json();
    //         if (infoData.error) throw new Error(infoData.error);

    //         // Fetch stream URL
    //         const streamResponse = await fetch(`/api/stream/${songId}`);
    //         const streamData = await streamResponse.json();
    //         if (streamData.error) throw new Error(streamData.error);

    //         // Start listening session
    //         const sessionResponse = await fetch('/api/listen/start', {
    //             method: 'POST',
    //             headers: { 'Content-Type': 'application/json' },
    //             body: JSON.stringify({
    //                 songId: songId,
    //                 title: infoData.title,
    //                 artist: infoData.artist
    //             })
    //         });
    //         const sessionData = await sessionResponse.json();
    //         currentListenId = sessionData.listenId;

    //         E.audio.src = streamData.url;
    //         await E.audio.load();

    //         // Update UI with backend-provided thumbnail
    //         updatePlayerInfo(infoData);

    //         loadLyrics(songId);
    //         loadArtistInfo(infoData.artist);

    //         await playAudioSafely();
    //         updatePlayPauseUI(true);
    //         syncProgress();
    //     } catch (e) {
    //         console.error("loadAndPlay error:", e);
    //         resetPlayerUI();
    //         showToast("Failed to load song. Please try again.");
    //     } finally {
    //         isAudioLoading = false;
    //     }
    // }

    async function loadAndPlay(songId) {
      if (songId === state.currentSongId) {
        togglePlay();
        return;
      }

      state.currentSongId = songId;
      E.miniPlayer.classList.remove("hidden");

      resetPlayerUI();
      E.progressSkeleton.style.opacity = "1";

      try {
        isAudioLoading = true;
        playAfterLoad = true;

        const infoResponse = await fetch(`/api/song-info/${songId}`);
        const infoData = await infoResponse.json();
        if (infoData.error) throw new Error(infoData.error);

        // Get current UTC timestamp from browser
        const clientTimestamp = new Date().toISOString();
        const streamResponse = await fetch(`/api/stream/${songId}?timestamp=${encodeURIComponent(clientTimestamp)}`);
        const streamData = await streamResponse.json();
        if (streamData.error) throw new Error(streamData.error);

        const sessionResponse = await fetch('/api/listen/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            songId: songId,
            title: infoData.title,
            artist: infoData.artist
          })
        });
        const sessionData = await sessionResponse.json();
        currentListenId = sessionData.listenId;

        E.audio.src = streamData.url;
        await E.audio.load();

        updatePlayerInfo(infoData);
        loadLyrics(songId);
        loadArtistInfo(infoData.artist);

        await playAudioSafely();
        updatePlayPauseUI(true);
        syncProgress();

        // Trigger history update
        loadMoreHistory();
      } catch (e) {
        console.error("loadAndPlay error:", e);
        resetPlayerUI();
        showToast("Failed to load song. Please try again.", "error");
      } finally {
        isAudioLoading = false;
      }
    }
    // Add this safe play function
    async function playAudioSafely() {
      try {
        if (isAudioLoading) {
          playAfterLoad = true;
          return;
        }

        if (E.audio.readyState >= 2) { // HAVE_CURRENT_DATA or better
          await E.audio.play();
        } else {
          playAfterLoad = true;
          E.audio.addEventListener('canplay', () => {
            if (playAfterLoad) {
              playAfterLoad = false;
              E.audio.play().catch(console.error);
            }
          }, { once: true });
        }
      } catch (error) {
        console.error('Play error:', error);
        if (error.name === 'AbortError') {
          // Try again after a short delay
          setTimeout(playAudioSafely, 100);
        }
      }
    }

    // Update the togglePlay function to use safe play
    function togglePlay() {
      if (!state.currentSongId) return;

      if (E.audio.paused) {
        playAudioSafely()
          .then(() => {
            updatePlayPauseUI(true);
          })
          .catch(err => {
            console.error("Play failed:", err);
            showToast("Playback failed. Please try again.");
          });
      } else {
        E.audio.pause();
        updatePlayPauseUI(false);
      }
    }

    // Add these event listeners to your audio element initialization
    E.audio.addEventListener('loadstart', () => {
      isAudioLoading = true;
      E.progressSkeleton.style.opacity = "1";  // Keep original loading indicator
    });

    E.audio.addEventListener('canplay', () => {
      isAudioLoading = false;
      E.progressSkeleton.style.opacity = "0";  // Keep original loading indicator
      if (playAfterLoad) {
        playAfterLoad = false;
        playAudioSafely();
      }
    });

    E.audio.addEventListener('error', () => {
      isAudioLoading = false;
      playAfterLoad = false;
      E.progressSkeleton.style.opacity = "0";
    });
    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', initializeAudio);
    /**
     * Update play/pause UI elements
     * @param {boolean} isPlaying - Current playing state
     */
    function updatePlayPauseUI(isPlaying) {
      const miniIcon = E.playButton.querySelector(".material-icons");
      const fullIcon = E.fullPlayButton.querySelector(".material-icons");

      miniIcon.textContent = isPlaying ? "pause_circle" : "play_circle";
      fullIcon.textContent = isPlaying ? "pause" : "play_arrow";

      state.isPlaying = isPlaying;

      if (isPlaying) {
        requestAnimationFrame(syncProgress);
      }
    }

    /**
     * Sync progress between mini and full player
     */
    function syncProgress() {
      if (E.audio.paused) return;

      const current = E.audio.currentTime;
      const duration = E.audio.duration;

      if (duration > 0) {
        const percent = (current / duration) * 100;
        E.progressBar.style.width = `${percent}%`;
        E.fullProgressBar.style.width = `${percent}%`;
      }

      E.currentTime.textContent = formatTime(current);
      E.fullCurrentTime.textContent = formatTime(current);
      E.totalTime.textContent = formatTime(duration);
      E.fullTotalTime.textContent = formatTime(duration);

      requestAnimationFrame(syncProgress);
    }

    /**
     * Reset player UI to loading state
     */
    function resetPlayerUI() {
      E.fullPlayerTitle.innerHTML = "<span>Loading...</span>";
      E.fullPlayerArtist.textContent = "Buffering...";
      E.fullPlayerArt.src = "/static/images/loading.png";
      E.lyricsContainer.innerHTML = '<div class="lyrics-line">Loading lyrics...</div>';
      E.artistImage.src = "";
      E.artistName.textContent = "Loading...";
      E.artistYear.textContent = "Year: -";
      E.artistGenre.textContent = "Genre: -";
      E.progressSkeleton.style.opacity = "1";
    }

    /**
     * Update player info with song details
     * @param {Object} info - Song information
     */
    function updatePlayerInfo(info) {
      const defaultThumb = '/static/images/default-cover.png';
      const externalThumb = `https://i.ytimg.com/vi/${info.id}/default.jpg`;
      const thumbnail = info.thumbnail || (info.id.startsWith('local-') ? defaultThumb : externalThumb);

      // Update mini player
      E.miniPlayerThumb.src = thumbnail;
      E.miniPlayerTitle.textContent = info.title || 'Unknown Title';
      E.miniPlayerArtist.textContent = info.artist || 'Unknown Artist';

      // Update full player
      E.fullPlayerArt.src = thumbnail;
      E.fullPlayerTitle.innerHTML = `<span>${info.title || 'Unknown Title'}</span>`;
      E.fullPlayerArtist.textContent = info.artist || 'Unknown Artist';

      document.title = `${info.title} - ${info.artist} | Music Player`;
      if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = new MediaMetadata({
          title: info.title || 'Unknown Title',
          artist: info.artist || 'Unknown Artist',
          artwork: [{ src: thumbnail, sizes: '512x512', type: 'image/jpg' }]
        });
      }
    }

    /**
     * Show play hint for autoplay restriction
     */
    function showPlayHint() {
      const hint = document.createElement('div');
      hint.style.cssText = `
    position: fixed;
    bottom: 120px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--accent-gradient);
    color: white;
    padding: 12px 24px;
    border-radius: 24px;
    font-size: 14px;
    z-index: 1000;
    animation: playHintPulse 2s infinite;
  `;
      hint.textContent = 'ðŸ‘† Click play to start listening';
      document.body.appendChild(hint);

      const removeHint = () => {
        hint.style.animation = 'toastOut 0.3s ease forwards';
        setTimeout(() => hint.remove(), 300);
      };

      document.addEventListener('click', removeHint, { once: true });
      setTimeout(removeHint, 5000);
    }

    /**
     * Audio Element Event Listeners
     */
    function setupAudioEventListeners() {
      E.audio.addEventListener("loadedmetadata", () => {
        E.totalTime.textContent = formatTime(E.audio.duration);
        E.fullTotalTime.textContent = formatTime(E.audio.duration);
        E.progressSkeleton.style.opacity = "0";
      });

      E.audio.addEventListener("playing", () => {
        state.isPlaying = true;
        updatePlayPauseUI(true);
      });

      E.audio.addEventListener("pause", () => {
        state.isPlaying = false;
        updatePlayPauseUI(false);
      });

      E.audio.addEventListener("ended", async () => {
        // End current listening session
        await endListeningSession(
          Math.round(E.audio.duration),
          Math.round(E.audio.currentTime)
        );

        state.isPlaying = false;
        updatePlayPauseUI(false);
        playNext();
      });

      // Add handler for when user stops/changes song
      E.audio.addEventListener("pause", async () => {
        if (currentListenId) {
          await endListeningSession(
            Math.round(E.audio.duration),
            Math.round(E.audio.currentTime)
          );
        }
      });

      E.audio.addEventListener("error", (e) => {
        console.error("Audio error:", e);
        showToast("Error playing audio. Please try again.");
      });
    }

    /**
     * Enhanced Music Player - Complete JavaScript Implementation
     * =======================================================
     *
     * PART 4: Queue Management & Search Functionality
     */

    /**
     * Queue Management Functions
     * Handles song queue and playback sequence
     */

    /**
     * Add song to queue and play
     * @param {string} songId - ID of song to queue and play
     */
    async function queueAndPlaySong(songId) {
      // Reset queue if it's too large
      if (state.queue.length > state.maxQueueSize) {
        state.queue = [];
        state.queueIndex = -1;
      }

      addToQueue(songId);
      state.queueIndex = state.queue.indexOf(songId);

      await loadAndPlay(songId);

      // Preload recommendations
      try {
        const response = await fetch(`/api/get-recommendations/${songId}`);
        const recommendations = await response.json();

        if (Array.isArray(recommendations)) {
          recommendations.forEach(song => {
            if (!state.queue.includes(song.id)) {
              state.queue.push(song.id);
            }
          });
        }
      } catch (error) {
        console.error("Error prefetching recommendations:", error);
      }
    }

    /**
     * Add song to queue
     * @param {string} songId - ID of song to add
     */
    function addToQueue(songId) {
      if (!state.queue.includes(songId)) {
        state.queue.push(songId);
      }
    }

    /**
     * Play next song in queue
     */
    async function playNext() {
      if (!state.currentSongId) return;

      // Try queue first
      if (state.queueIndex < state.queue.length - 1) {
        state.queueIndex++;
        await loadAndPlay(state.queue[state.queueIndex]);
        return;
      }

      try {
        const response = await fetch(`/api/play-sequence/${state.currentSongId}/next`);
        const data = await response.json();

        if (response.status === 404) {
          return; // No next song
        }

        if (data.error) {
          console.warn("Next song error:", data.error);
          return;
        }

        // Handle both single song and recommendations array
        const nextSongs = Array.isArray(data) ? data : [data];

        // Add new songs to queue
        nextSongs.forEach(song => {
          if (!state.queue.includes(song.id)) {
            state.queue.push(song.id);
          }
        });

        const nextSongId = nextSongs[0].id;
        state.queueIndex = state.queue.indexOf(nextSongId);
        await loadAndPlay(nextSongId);

      } catch (error) {
        console.error("Error playing next:", error);
        showToast("Failed to play next song");
      }
    }

    /**
     * Play previous song in queue
     */
    async function playPrevious() {
      if (!state.currentSongId) return;

      // Try queue first
      if (state.queueIndex > 0) {
        state.queueIndex--;
        await loadAndPlay(state.queue[state.queueIndex]);
        return;
      }

      try {
        const response = await fetch(`/api/play-sequence/${state.currentSongId}/previous`);
        const data = await response.json();

        if (response.status === 404) {
          // If no previous song, restart current song if played for a while
          if (E.audio.currentTime > 3) {
            E.audio.currentTime = 0;
          }
          return;
        }

        if (data.error) {
          if (E.audio.currentTime > 3) {
            E.audio.currentTime = 0;
          }
          return;
        }

        // Add to queue if not exists
        if (!state.queue.includes(data.id)) {
          state.queue.splice(state.queueIndex, 0, data.id);
        }

        state.queueIndex = state.queue.indexOf(data.id);
        await loadAndPlay(data.id);

      } catch (error) {
        console.error("Error playing previous:", error);
        if (E.audio.currentTime > 3) {
          E.audio.currentTime = 0;
        }
      }
    }

    /**
     * Search Functionality
     * Handles search and results display
     */

    /**
     * Load search results with deduplication
     * @param {boolean} reset - Whether to reset search state
     */
    async function loadSearchResults(reset = false) {
      if (reset) {
        state.searchPage = 0;
        state.searchHasMore = true;
        E.resultsContainer.innerHTML = "";
        state.displayedItems.clear();
      }

      if (!state.searchHasMore || state.loadingMore) return;

      state.loadingMore = true;
      E.infiniteLoader.style.display = "block";

      if (state.searchPage === 0) {
        showSkeleton();
      }

      try {
        const q = encodeURIComponent(state.searchQuery);
        const page = state.searchPage;
        const limit = state.searchLimit;
        const res = await fetch(`/api/search?q=${q}&page=${page}&limit=${limit}`);
        const newResults = await res.json();

        if (state.searchPage === 0) {
          E.resultsContainer.innerHTML = ""; // Clear only on reset
        }

        if (!Array.isArray(newResults) || newResults.length === 0) {
          state.searchHasMore = false;
          if (state.searchPage === 0) {
            E.resultsContainer.innerHTML = "<p>No results found.</p>";
          }
        } else {
          // Create a set of new result IDs for comparison
          const newIds = new Set(newResults.map(song => song.id));

          // Remove results no longer in the new list (only if not resetting)
          if (!reset) {
            const currentItems = E.resultsContainer.querySelectorAll('.result-item');
            currentItems.forEach(item => {
              const songId = item.dataset.id;
              if (!newIds.has(songId) && state.displayedItems.has(songId)) {
                item.remove();
                state.displayedItems.delete(songId);
              }
            });
          }

          // Append only new, unique results
          newResults.forEach(song => {
            if (!state.displayedItems.has(song.id)) {
              displayResults([song]); // Pass single song as array
              state.displayedItems.add(song.id);
            }
          });

          // Update pagination
          state.searchPage += 1;
          state.searchHasMore = newResults.length === state.searchLimit;
        }
      } catch (error) {
        console.error("Error loading search results:", error);
        showToast("Failed to load results. Please try again.", "error");
      } finally {
        state.loadingMore = false;
        E.infiniteLoader.style.display = "none";
      }
    }
    /**
     * Display search results
     * @param {Array} items - Array of song items to display
     */
    function displayResults(items) {
      const uniqueItems = items.filter(song => {
        const key = `${song.id}-${song.title}-${song.artist}`.toLowerCase();
        if (state.displayedItems.has(song.id) || state.displayedItems.has(key)) {
          return false;
        }
        state.displayedItems.add(song.id);
        state.displayedItems.add(key);
        return true;
      });

      if (uniqueItems.length === 0) return;

      const html = uniqueItems.map(song => `
        <div class="song-card" data-id="${song.id}">
            <div class="song-thumbnail-container">
                <img class="song-thumbnail"
                     loading="lazy"
                     src="${song.thumbnail || '/static/images/default-cover.png'}"
                     alt="${song.title}">
            </div>
            <div class="song-info">
                <div class="song-title">${song.title}</div>
                <div class="song-artist">${song.artist}</div>
            </div>
        </div>
    `).join('');
      E.resultsContainer.insertAdjacentHTML('beforeend', html);
    }

    /**
     * Show skeleton loading animation
     */
    function showSkeleton() {
      E.resultsContainer.innerHTML = Array(6).fill("")
        .map(() => `<div class="song-card skeleton"></div>`)
        .join("");
    }

    /**
     * Check if item is already displayed
     * @param {Object} item - Song item to check
     * @returns {boolean} Whether item is already displayed
     */
    // Enhanced isItemDisplayed function with better duplicate detection
    function isItemDisplayed(item) {
      // Create a unique signature for the item that considers multiple factors
      const signatures = [
        // Basic ID check
        item.id,

        // Title + Artist normalized signature
        `${item.title}-${item.artist}`.toLowerCase().trim(),

        // Title-only normalized signature (for covers/remixes)
        item.title.toLowerCase().trim(),

        // Clean-text signature (removes special characters)
        `${item.title}-${item.artist}`
          .toLowerCase()
          .replace(/[^\w\s-]/g, '')
          .trim()
      ];

      // Check if any signature exists in our tracking set
      return signatures.some(sig => state.displayedItems.has(sig));
    }

    // Enhanced displayResults function with improved deduplication
    function displayResults(items) {
      const uniqueItems = items.filter(song => {
        if (isItemDisplayed(song)) {
          return false;
        }

        // Add all signatures to tracking set
        const signatures = [
          song.id,
          `${song.title}-${song.artist}`.toLowerCase().trim(),
          song.title.toLowerCase().trim(),
          `${song.title}-${song.artist}`
            .toLowerCase()
            .replace(/[^\w\s-]/g, '')
            .trim()
        ];

        signatures.forEach(sig => state.displayedItems.add(sig));
        return true;
      });

      // Rest of the display logic...
      if (uniqueItems.length === 0) return;

      const html = uniqueItems.map(song => `
    <div class="song-card" data-id="${song.id}">
      <div class="song-thumbnail-container">
        <img class="song-thumbnail"
             loading="lazy"
             src="${song.thumbnail || "/static/images/default-cover.png"}"
             alt="${song.title}">
        <div class="song-duration">${formatTime(song.duration)}</div>
      </div>
      <div class="song-info">
        <div class="song-title">${song.title}</div>
        <div class="song-artist">${song.artist}</div>
      </div>
    </div>
  `).join("");

      E.resultsContainer.insertAdjacentHTML("beforeend", html);

      // Add click handlers
      document.querySelectorAll(".song-card").forEach(card => {
        if (!card.hasListener) {
          card.hasListener = true;
          card.addEventListener("click", () => {
            const sid = card.dataset.id;
            queueAndPlaySong(sid);
          });
        }
      });
    }

    // Reset function to clear tracking when starting new search
    function resetSearchState() {
      state.searchPage = 0;
      state.searchHasMore = true;
      E.resultsContainer.innerHTML = "";
      state.displayedItems.clear();
    }

    // Debounced search function
    const doSearch = debounce(() => {
      state.searchQuery = E.searchInput.value.trim();
      loadSearchResults(true);
    }, 400);

    // Search input handler
    E.searchInput.addEventListener("input", () => {
      if (E.searchInput.value.trim()) {
        E.broomIcon.style.display = "block";
      } else {
        E.broomIcon.style.display = "none";
        state.displayedItems.clear();
      }
      doSearch();
    });

    // Clear search handler
    E.broomIcon.addEventListener("click", () => {
      E.searchInput.value = "";
      E.broomIcon.style.display = "none";
      state.displayedItems.clear();
      doSearch();
    });
    /**
     * Enhanced Music Player - Complete JavaScript Implementation
     * =======================================================
     *
     * PART 5: Initialization and Event Bindings
     */

    /**
     * Setup all event listeners
     * Initializes all event handlers for the application
     */
    function setupEventListeners() {
      // Keyboard shortcuts
      document.addEventListener("keydown", e => {
        // if (e.code === "Space" && e.target === document.body) {
        //   e.preventDefault();
        //   togglePlay();
        // }
        // if (e.code === "Space" && e.target !== E.searchInput) {
        //   e.preventDefault();
        //   togglePlay();
        // }
        const isTypingElement = e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable);

        if (e.code === "Space" && !isTypingElement) { // Check if space is pressed AND we are NOT typing in an input/textarea
          e.preventDefault(); // Prevent default ONLY when not typing (e.g., prevent page scroll)
          togglePlay();
        }
        if ((e.code === "ArrowLeft" || e.key === ",") && (e.ctrlKey || e.shiftKey)) {
          e.preventDefault();
          playPrevious();
        }
        if ((e.code === "ArrowRight" || e.key === ".") && (e.ctrlKey || e.shiftKey)) {
          e.preventDefault();
          playNext();
        }
        if (e.code === "Escape") {
          E.fullPlayer.classList.remove("active");
        }
      });

      // Mini player controls
      E.playButton.addEventListener('click', togglePlay);
      E.prevButton.addEventListener('click', playPrevious);
      E.nextButton.addEventListener('click', playNext);

      // Full player controls
      E.fullPlayButton.addEventListener('click', togglePlay);
      E.fullPrevButton.addEventListener('click', playPrevious);
      E.fullNextButton.addEventListener('click', playNext);

      // Volume control
      E.volumeSlider.addEventListener("input", handleVolumeChange);
      E.volumeButton.addEventListener("click", toggleMute);

      // Player expand/minimize
      E.expandButton.addEventListener("click", () => {
        E.fullPlayer.classList.add("active");
      });

      E.minimizeButton.addEventListener("click", () => {
        E.fullPlayer.classList.remove("active");
      });

      // Define the debounced loadMore function
      const loadMoreDebounced = debounce(() => {
        if (!state.loadingMore && state.searchHasMore) {
          loadSearchResults(false);
        }
      }, 200);

      // Update scroll event listener
      window.addEventListener('scroll', () => {
        const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
        if (scrollTop + clientHeight >= scrollHeight - 100) {
          loadMoreDebounced();
        }
      });

      // Window focus handling
      window.addEventListener('focus', () => {
        // Resume progress tracking if playing
        if (state.isPlaying) {
          requestAnimationFrame(syncProgress);
        }
      });
    }

    /**
     * Setup random song or handle shared link
     */
    async function setupInitialSong() {
      const urlParams = new URLSearchParams(window.location.search);
      const sharedSongId = urlParams.get('song');

      try {
        let songToPreload = null;

        if (sharedSongId) {
          const response = await fetch(`/api/song-info/${sharedSongId}`);
          songToPreload = await response.json();
        } else {
          songToPreload = await getRandomSong();
        }

        if (songToPreload) {
          state.currentSongId = songToPreload.id;
          E.miniPlayer.classList.remove("hidden");
          updatePlayerInfo(songToPreload);

          // Preload audio
          const streamData = await fetch(`/api/stream/${songToPreload.id}`).then(r => r.json());
          if (!streamData.error) {
            E.audio.src = streamData.url;
            E.audio.load();
          }

          // Add to queue
          if (!state.queue.includes(songToPreload.id)) {
            state.queue.push(songToPreload.id);
            state.queueIndex = state.queue.length - 1;
          }

          // Show play hint
          showPlayHint();

          // Load additional content
          loadLyrics(songToPreload.id);
          loadArtistInfo(songToPreload.artist);

          // Update URL if shared song
          if (sharedSongId) {
            history.replaceState({}, '', window.location.pathname);
          }
        }
      } catch (error) {
        console.error("Error preloading song:", error);
        showToast("Failed to load initial song");
      }
    }

    /**
     * Initialize application settings
     */
    // Updated initializeSettings function with proper audio context handling
    // 1. Fix AudioContext initialization
    function initializeAudioContext() {
      let audioContext;

      // Create context only after user interaction
      document.addEventListener('click', function initContext() {
        if (!audioContext) {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (AudioContext) {
            audioContext = new AudioContext();
            // Remove listener after first click
            document.removeEventListener('click', initContext);
          }
        }
      }, { once: true });

      return audioContext;
    }

    // 2. Fix setupInsights with null checks
    function setupInsights() {
      const insightsButton = document.querySelector('.player-controls .control-button[title="View Insights"]');
      const insightsModal = document.getElementById('insightsModal');
      const closeInsights = document.getElementById('closeInsights');

      if (!insightsButton || !insightsModal || !closeInsights) {
        console.warn('Insights elements not found, skipping setup');
        return;
      }

      insightsButton.addEventListener('click', async () => {
        insightsModal.style.display = 'block';
        await loadInsights();
      });

      closeInsights.addEventListener('click', () => {
        insightsModal.style.display = 'none';
      });
    }



    // 4. Update initialization function
    async function init() {
      try {
        // Initialize base settings with delayed AudioContext
        initializeSettings();

        // Setup all event listeners
        setupEventListeners();
        setupAudioEventListeners();

        // Initialize components with error handling
        setupSpeechRecognition();
        initializePlayerControls();
        checkProtocolAndShowWarning();

        // Initialize charts first
        const chartsInitialized = await initializeCharts();

        // Only setup insights if charts initialized successfully
        if (chartsInitialized) {
          setupInsights();
        }

        // Setup progress bars
        setupProgressBar(E.progressContainer, E.progressHover);
        setupProgressBar(E.fullProgressContainer, E.fullProgressHover);

        // Load initial song
        await setupInitialSong();

        // Load initial search results
        state.searchQuery = "";
        await loadSearchResults(true);


      } catch (error) {
        console.error("Initialization error:", error);
        showToast("An error occurred during initialization");
      }
    }

    // 5. Update initializeSettings function
    function initializeSettings() {
      // Set initial volume
      const savedVolume = localStorage.getItem("player-volume");
      if (savedVolume) {
        state.volume = parseInt(savedVolume);
        E.volumeSlider.value = state.volume;
        E.audio.volume = state.volume / 100;
        updateVolumeIcon(state.volume);
      }

      // Setup audio quality with delayed initialization
      let audioContext;
      document.addEventListener('click', () => {
        if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
          try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext?.audioWorklet) {
              setupAudioWorklet(audioContext).catch(console.warn);
            }
          } catch (err) {
            console.warn('AudioContext initialization failed:', err);
          }
        }
      }, { once: true });

      // Setup player appearance from preferences
      const savedTheme = localStorage.getItem("player-theme");
      if (savedTheme) {
        document.documentElement.setAttribute('data-theme', savedTheme);
      }
    }

    /**
     * Main initialization function
     * Entry point for the application
     */
    async function init() {
      try {
        // Initialize base settings
        initializeSettings();

        // Setup all event listeners
        setupEventListeners();
        setupAudioEventListeners();

        // Initialize components
        setupSpeechRecognition();
        initializePlayerControls();
        showToast("Welcome To Sangeet Premium Plus...")
        await initializeCharts();
        setupInsights(); // Move setupInsights here

        // Setup progress bars
        setupProgressBar(E.progressContainer, E.progressHover);
        setupProgressBar(E.fullProgressContainer, E.fullProgressHover);

        // Load initial song
        await setupInitialSong();

        // Load initial search results
        state.searchQuery = "";
        await loadSearchResults(true);

      } catch (error) {
        console.error("Initialization error:", error);
        showToast("An error occurred during initialization");
      }
    }
    // Initialize all charts for the insights view
    async function initializeCharts() {
      try {
        // Create container divs for charts if they don't exist
        const chartContainers = ['dailyPatternChart', 'hourlyPatternChart', 'completionChart'];

        chartContainers.forEach(containerId => {
          const container = document.getElementById(containerId);
          if (container) {
            // Clear existing content
            container.innerHTML = '';
            // Add canvas element
            const canvas = document.createElement('canvas');
            canvas.id = `${containerId}Canvas`;
            container.appendChild(canvas);
          }
        });

        // Initialize empty charts with default configurations
        const ctx = {
          daily: document.getElementById('dailyPatternChartCanvas')?.getContext('2d'),
          hourly: document.getElementById('hourlyPatternChartCanvas')?.getContext('2d'),
          completion: document.getElementById('completionChartCanvas')?.getContext('2d')
        };

        // Only proceed if Chart.js is loaded
        if (!window.Chart) {
          console.warn('Chart.js not loaded yet');
          return false;
        }

        // Set default chart options
        Chart.defaults.color = '#94a3b8';
        Chart.defaults.font.family = 'system-ui, sans-serif';
        Chart.defaults.plugins.legend.display = false;
        Chart.defaults.animation.duration = 2000;
        Chart.defaults.elements.line.tension = 0.4;

        // Initialize empty charts
        if (ctx.daily) {
          window.chartInstances = window.chartInstances || {};
          window.chartInstances.daily = new Chart(ctx.daily, {
            type: 'bar',
            data: {
              labels: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
              datasets: [{
                data: Array(7).fill(0),
                backgroundColor: 'rgba(79,70,229,0.2)',
                borderColor: 'rgba(79,70,229,0.8)',
                borderWidth: 2,
                borderRadius: 4
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  grid: {
                    color: 'rgba(148,163,184,0.1)'
                  }
                },
                x: {
                  grid: {
                    display: false
                  }
                }
              }
            }
          });
        }

        if (ctx.hourly) {
          window.chartInstances.hourly = new Chart(ctx.hourly, {
            type: 'line',
            data: {
              labels: Array.from({ length: 24 }, (_, i) => `${i}:00`),
              datasets: [{
                data: Array(24).fill(0),
                backgroundColor: 'rgba(129,140,248,0.2)',
                borderColor: 'rgba(129,140,248,0.8)',
                borderWidth: 2,
                fill: true
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  grid: {
                    color: 'rgba(148,163,184,0.1)'
                  }
                },
                x: {
                  grid: {
                    display: false
                  }
                }
              }
            }
          });
        }

        if (ctx.completion) {
          window.chartInstances.completion = new Chart(ctx.completion, {
            type: 'doughnut',
            data: {
              labels: ['Complete', 'Partial', 'Skipped'],
              datasets: [{
                data: [0, 0, 0],
                backgroundColor: [
                  'rgba(79,70,229,0.8)',
                  'rgba(129,140,248,0.8)',
                  'rgba(199,210,254,0.8)'
                ],
                borderWidth: 0
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              cutout: '70%',
              plugins: {
                legend: {
                  display: true,
                  position: 'bottom'
                }
              }
            }
          });
        }

        return true;

      } catch (error) {
        console.error('Error initializing charts:', error);
        return false;
      }
    }
    /**
     * Error handler for uncaught errors
     */
    window.onerror = function (msg, url, line, col, error) {
      console.error("Global error:", { msg, url, line, col, error });
      // showToast("An unexpected error occurred");
      return false;
    };

    /**
     * Handle unhandled promise rejections
     */
    window.onunhandledrejection = function (event) {
      console.error("Unhandled promise rejection:", event.reason);
      showToast("An unexpected error occurred");
    };

    // Start the application
    document.addEventListener("DOMContentLoaded", init);

    // Export functions for potential external use
    window.PlayerAPI = {
      togglePlay,
      playNext,
      playPrevious,
      updateVolume: handleVolumeChange,
      toggleMute,
      seekTo: (time) => {
        if (E.audio.duration) {
          E.audio.currentTime = time;
        }
      }
    };
    /**
     * Lyrics and Artist Info Functions
     * Handles loading and displaying song metadata
     */

    /**
     * Load and display lyrics for a song
     * @param {string} songId - ID of song to load lyrics for
     */
    //      async function loadLyrics(songId) {
    //   // Set loading state
    //   E.lyricsContainer.innerHTML = '<div class="lyrics-line loading">Loading lyrics...</div>';

    //   try {
    //     const response = await fetch(`/api/lyrics/${songId}`);
    //     if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    //     const lines = await response.json();

    //     // Validate lyrics data
    //     if (!Array.isArray(lines) || !lines.length) {
    //       E.lyricsContainer.innerHTML = `
    //         <div class="lyrics-line no-lyrics">
    //           No lyrics available
    //         </div>`;
    //       return;
    //     }

    //     // Clear container and prepare for new lyrics
    //     E.lyricsContainer.innerHTML = '';

    //     // Add lyrics with staggered animation and enhanced styling
    //     lines.forEach((line, index) => {
    //       const div = document.createElement('div');
    //       div.className = 'lyrics-line';
    //       div.textContent = line.trim() || '\u00A0'; // Use non-breaking space for empty lines
    //       div.dataset.index = index; // For potential future use (e.g., highlighting)

    //       // Initial state for animation
    //       div.style.opacity = '0';
    //       div.style.transform = 'translateY(20px)';
    //       div.style.transition = 'none'; // Prevent premature transitions

    //       E.lyricsContainer.appendChild(div);

    //       // Trigger animation with delay
    //       setTimeout(() => {
    //         div.style.transition = 'all 0.5s ease-out';
    //         div.style.opacity = '1';
    //         div.style.transform = 'translateY(0)';
    //       }, index * 150); // Increased delay for smoother effect
    //     });

    //     // Ensure container has modern styling (fallback if CSS is missing)
    //     E.lyricsContainer.style.background = E.lyricsContainer.style.background || 
    //       'linear-gradient(135deg, rgba(10, 10, 20, 0.95), rgba(40, 40, 60, 0.85))';
    //     E.lyricsContainer.style.borderRadius = '12px';
    //     E.lyricsContainer.style.padding = '20px';
    //     E.lyricsContainer.style.boxShadow = '0 8px 24px rgba(0, 0, 0, 0.2)';
    //     E.lyricsContainer.style.overflowY = 'auto'; // Scroll if too many lines

    //   } catch (error) {
    //     console.error('Error loading lyrics:', error);
    //     E.lyricsContainer.innerHTML = `
    //       <div class="lyrics-line error">
    //         Unable to load lyrics
    //       </div>`;
    //   }
    // }

    async function loadLyrics(songId) {
      // Set loading state
      E.lyricsContainer.innerHTML = '<div class="lyrics-line loading">Loading lyrics...</div>';
      E.lyricsContainer.style.opacity = '1'; // Ensure container is visible
      E.lyricsContainer.style.transition = 'opacity 0.3s ease-out'; // Add transition

      try {
        const response = await fetch(`/api/lyrics/${songId}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const lines = await response.json();

        // Validate lyrics data
        if (!Array.isArray(lines) || !lines.length) {
          // Smoothly hide container instead of showing "No lyrics available"
          E.lyricsContainer.style.opacity = '0';
          setTimeout(() => {
            E.lyricsContainer.innerHTML = ''; // Clear content after fade
            E.lyricsContainer.style.display = 'none'; // Hide completely
          }, 300); // Match transition duration
          return;
        }

        // Clear container and prepare for new lyrics
        E.lyricsContainer.style.display = 'block'; // Ensure visible if previously hidden
        E.lyricsContainer.innerHTML = '';

        // Add lyrics with staggered animation and enhanced styling
        lines.forEach((line, index) => {
          const div = document.createElement('div');
          div.className = 'lyrics-line';
          div.textContent = line.trim() || '\u00A0';
          div.dataset.index = index;

          // Initial state for animation
          div.style.opacity = '0';
          div.style.transform = 'translateY(20px)';
          div.style.transition = 'none';

          E.lyricsContainer.appendChild(div);

          // Trigger animation with delay
          setTimeout(() => {
            div.style.transition = 'all 0.5s ease-out';
            div.style.opacity = '1';
            div.style.transform = 'translateY(0)';
          }, index * 150);
        });

        // Ensure container has modern styling
        E.lyricsContainer.style.background = E.lyricsContainer.style.background ||
          'linear-gradient(135deg, rgba(10, 10, 20, 0.95), rgba(40, 40, 60, 0.85))';
        E.lyricsContainer.style.borderRadius = '12px';
        E.lyricsContainer.style.padding = '20px';
        E.lyricsContainer.style.boxShadow = '0 8px 24px rgba(0, 0, 0, 0.2)';
        E.lyricsContainer.style.overflowY = 'auto';

      } catch (error) {
        console.error('Error loading lyrics:', error);
        // Fade out on error as well
        E.lyricsContainer.style.opacity = '0';
        setTimeout(() => {
          E.lyricsContainer.innerHTML = ''; // Clear content
          E.lyricsContainer.style.display = 'none'; // Hide completely
        }, 300);
      }
    }
    /**
     * Load and display artist information
     * @param {string} artistName - Name of artist to load info for
     */
    async function loadArtistInfo(artistName) {
      try {
        const response = await fetch(`/api/artist-info/${encodeURIComponent(artistName)}`);
        const data = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        E.artistImage.src = data.thumbnail || '';
        E.artistName.textContent = data.name || artistName;
        E.artistYear.textContent = `Active since: ${data.year || 'Unknown'}`;
        E.artistGenre.textContent = `Genre: ${data.genres?.join(', ') || 'Various'}`;

        // Animate the artist info update
        const elements = [E.artistImage, E.artistName, E.artistYear, E.artistGenre];
        elements.forEach(el => {
          el.style.opacity = '0';
          el.style.transform = 'translateY(10px)';
          requestAnimationFrame(() => {
            el.style.transition = 'all 0.3s ease';
            el.style.opacity = '1';
            el.style.transform = 'translateY(0)';
          });
        });

      } catch (error) {
        console.error('Error loading artist info:', error);
        // Show fallback info
        E.artistImage.src = '';
        E.artistName.textContent = artistName;
        E.artistYear.textContent = 'Year: -';
        E.artistGenre.textContent = 'Genre: -';
      }
    }

    /**
     * Get a random song from available songs
     * @returns {Promise<Object>} Random song object
     */
    async function getRandomSong() {
      try {
        const response = await fetch('/api/random-song');
        if (!response.ok) throw new Error('Failed to get random song');
        return await response.json();
      } catch (error) {
        console.error('Error getting random song:', error);
        showToast("Failed to load random song");
        return null;
      }
    }
  </script>
  <script>
    // Add integration button to full player controls
    const integrationButton = document.createElement('button');
    integrationButton.className = 'control-button';
    integrationButton.innerHTML = '<span class="material-icons">code</span>';
    integrationButton.title = 'Get embed code';
    document.querySelector('.full-player .player-controls').appendChild(integrationButton);

    // Integration state
    const integrationState = {
      size: 'normal',
      theme: 'default',
      serverDomain: window.location.origin
    };

    // Add container to full player
    document.getElementById('fullPlayer').insertAdjacentHTML('beforeend', document.getElementById('integrationContainer').outerHTML);

    // Integration handling
    function initializeIntegration() {
      const container = document.getElementById('integrationContainer');
      const closeBtn = document.getElementById('closeIntegration');
      const copyBtn = document.getElementById('copyCode');
      const sizeBtns = container.querySelectorAll('.size-btn');
      const themeBtns = container.querySelectorAll('.theme-btn');

      // Show integration panel
      integrationButton.addEventListener('click', () => {
        container.style.display = 'block';
        updatePreviewAndCode();
      });

      // Close panel
      closeBtn.addEventListener('click', () => {
        container.style.display = 'none';
      });

      // Size selection
      sizeBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          sizeBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          integrationState.size = btn.dataset.size;
          updatePreviewAndCode();
        });
      });

      // Theme selection
      themeBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          themeBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          integrationState.theme = btn.dataset.theme;
          updatePreviewAndCode();
        });
      });

      // Copy code
      copyBtn.addEventListener('click', async () => {
        const code = document.getElementById('embedCode').textContent;
        try {
          await navigator.clipboard.writeText(code);
          copyBtn.innerHTML = '<span class="material-icons">check</span>';
          setTimeout(() => {
            copyBtn.innerHTML = '<span class="material-icons">content_copy</span>';
          }, 2000);
        } catch (err) {
          console.error('Failed to copy:', err);
          showToast('Failed to copy code');
        }
      });
    }

    document.addEventListener('DOMContentLoaded', async () => {
      try {
        // Load Chart.js first
        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js');

        // Then load the datalabels plugin
        await loadScript('https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0');

        // Now wait a moment to ensure proper initialization
        await new Promise(resolve => setTimeout(resolve, 100));

        if (window.Chart && window.ChartDataLabels) {
          // Register the plugin
          Chart.register(ChartDataLabels);

          // Set default Chart.js options
          Chart.defaults.font.family = 'sans-serif';
          Chart.defaults.color = '#94a3b8';
          Chart.defaults.elements.line.borderJoinStyle = 'round';
          Chart.defaults.elements.bar.borderRadius = 4;

          await initializeCharts();
          setupInsights();
        } else {
          console.error('Chart.js or ChartDataLabels not properly loaded');
        }
      } catch (err) {
        console.error('Error initializing charts:', err);
      }
    });


    // Handle window resizing
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (window.chartInstances) {
          Object.values(window.chartInstances).forEach(chart => {
            if (chart && typeof chart.resize === 'function') {
              chart.resize();
            }
          });
        }
      }, 250);
    });

    // Helper function to load scripts
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }



    // Update preview and code
    async function updatePreviewAndCode() {
      if (!state.currentSongId) return;

      const dimensions = {
        small: { width: 320, height: 160 },
        normal: { width: 400, height: 200 },
        large: { width: 500, height: 240 }
      };

      const { width, height } = dimensions[integrationState.size];

      // Update preview iframe
      const previewFrame = document.getElementById('previewFrame');
      previewFrame.style.width = `${width}px`;
      previewFrame.style.height = `${height}px`;

      const embedUrl = `${integrationState.serverDomain}/embed/${state.currentSongId}?size=${integrationState.size}&theme=${integrationState.theme}`;
      previewFrame.src = embedUrl;

      // Generate embed code
      const embedCode = `<iframe
  src="${embedUrl}"
  width="${width}"
  height="${height}"
  frameborder="0"
  allowtransparency="true"
  allow="encrypted-media"
  loading="lazy">
</iframe>`;

      document.getElementById('embedCode').textContent = embedCode;
    }

    // Initialize integration features
    initializeIntegration();

    // Update preview when song changes
    const originalLoadAndPlay = window.loadAndPlay;
    window.loadAndPlay = async function (songId) {
      await originalLoadAndPlay(songId);
      if (document.getElementById('integrationContainer').style.display === 'block') {
        updatePreviewAndCode();
      }
    };
    async function loadArtistDetails(artistName) {
      try {
        const response = await fetch(`/api/artist-info/${encodeURIComponent(artistName)}`);
        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to load artist details');
        }

        // Update description
        document.getElementById('artistDescription').textContent = data.description || 'No description available';

        // Update stats
        document.getElementById('artistSubscribers').textContent = data.stats?.subscribers || '-';
        document.getElementById('artistViews').textContent = data.stats?.views || '-';
        document.getElementById('artistMonthlyListeners').textContent = data.stats?.monthlyListeners || '-';

        // Update top songs
        const topSongsList = document.getElementById('topSongsList');
        topSongsList.innerHTML = '';

        if (data.topSongs && data.topSongs.length > 0) {
          data.topSongs.forEach((song, index) => {
            const songElement = `
          <div class="top-song-item" data-song-id="${song.videoId}">
            <div class="song-number">${index + 1}</div>
            <div class="song-info">
              <div class="song-title">${song.title}</div>
              <div class="song-plays">${song.plays} plays</div>
            </div>
          </div>
        `;
            topSongsList.insertAdjacentHTML('beforeend', songElement);
          });

          // Add click handlers for top songs
          topSongsList.querySelectorAll('.top-song-item').forEach(item => {
            item.addEventListener('click', () => {
              const songId = item.dataset.songId;
              if (songId) {
                loadAndPlay(songId);
              }
            });
          });
        }

        // Update links
        const linksContainer = document.getElementById('artistLinks');
        linksContainer.innerHTML = '';

        if (data.links?.youtube) {
          const youtubeLink = `
        <a href="${data.links.youtube}" target="_blank" rel="noopener noreferrer" class="artist-link">
          <span class="material-icons">play_circle</span>
          YouTube Music
        </a>
      `;
          linksContainer.insertAdjacentHTML('beforeend', youtubeLink);
        }

        if (data.links?.official) {
          const officialLink = `
        <a href="${data.links.official}" target="_blank" rel="noopener noreferrer" class="artist-link">
          <span class="material-icons">language</span>
          Official Website
        </a>
      `;
          linksContainer.insertAdjacentHTML('beforeend', officialLink);
        }

      } catch (error) {
        console.error('Error loading artist details:', error);
        document.getElementById('artistDescription').textContent = 'Failed to load artist details';
      }
    }

    // Update the existing loadArtistInfo function to also call our new function
    const originalLoadArtistInfo = window.loadArtistInfo;
    window.loadArtistInfo = async function (artistName) {
      await originalLoadArtistInfo(artistName);
      await loadArtistDetails(artistName);
    };
    window.onunhandledrejection = function (event) {
      if (event.reason.message.includes('AudioWorklet')) {
        console.warn('AudioWorklet error suppressed:');
        event.preventDefault();
      }
    };

  </script>
  <script>
    // Enhanced insights visualization with Chart.js

    // Utility for generating gradients
    function createGradient(ctx, colorStart, colorEnd) {
      const gradient = ctx.createLinearGradient(0, 0, 0, 300);
      gradient.addColorStop(0, colorStart);
      gradient.addColorStop(1, colorEnd);
      return gradient;
    }




    // Enhanced initialization with chart responsiveness
    document.addEventListener('DOMContentLoaded', () => {
      // Load Chart.js with animation plugin
      Promise.all([
        loadScript('https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js'),
        loadScript('https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0')
      ]).then(() => {
        // Register Chart.js plugins
        Chart.register(ChartDataLabels);

        // Set default Chart.js options for all charts
        Chart.defaults.font.family = 'sans-serif';
        Chart.defaults.color = '#94a3b8';
        Chart.defaults.elements.line.borderJoinStyle = 'round';
        Chart.defaults.elements.bar.borderRadius = 4;
      }).catch(err => {
        console.error('Error loading chart libraries:', err);
        // showToast('Failed to load visualization libraries');
      });
    });
    // Add insights button to controls
    const insightsButton = document.createElement('button');
    insightsButton.className = 'control-button';
    insightsButton.innerHTML = '<span class="material-icons">insights</span>';
    insightsButton.title = 'View Insights';
    document.querySelector('.player-controls').appendChild(insightsButton);

    // Insights modal handling
    const insightsModal = document.getElementById('insightsModal');
    const closeInsights = document.getElementById('closeInsights');

    insightsButton.addEventListener('click', () => {
      insightsModal.style.display = 'block';
      loadInsights();
    });

    closeInsights.addEventListener('click', () => {
      insightsModal.style.display = 'none';
    });
    // Format duration for insights
    function formatInsightDuration(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) {
        return `${days}d ${hours % 24}h`;
      } else if (hours > 0) {
        return `${hours}h ${minutes}m`;
      }
      return `${minutes}m`;
    }

    // Helper function to update recent activity
    function updateRecentActivity(activities) {
      const recentActivityList = document.getElementById('recentActivityList');
      recentActivityList.innerHTML = activities.map((activity, index) => `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${formatRelativeTime(new Date(activity.started_at))}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `).join('');
    }

    // Initialize global chart instances object
    window.chartInstances = {
      daily: null,
      hourly: null,
      completion: null
    };
    const TimeUtils = {
      /**
       * Format time with IST timezone
       * @param {Date|string} date - Date to format
       * @param {boolean} includeDate - Whether to include date in output
       * @returns {string} Formatted time string
       */
      formatTime(date, includeDate = false) {
        if (!date) return '->';

        try {
          const d = new Date(date);
          // Convert to IST
          const istTime = new Date(d.getTime() + (5.5 * 60 * 60 * 1000));

          const options = {
            hour: 'numeric',
            minute: 'numeric',
            hour12: true,
            timeZone: 'Asia/Kolkata'
          };

          if (includeDate) {
            options.day = 'numeric';
            options.month = 'short';
            options.year = 'numeric';
          }

          return istTime.toLocaleString('en-IN', options) + ' IST';
        } catch (e) {
          console.error('Time formatting error:', e);
          return '->';
        }
      },

      /**
       * Format relative time in IST
       * @param {Date|string} date - Date to format
       * @returns {string} Relative time string
       */
      formatRelativeTime(date) {
        if (!date) return 'Unknown time';

        try {
          const now = new Date();
          const then = new Date(date);

          // Convert both to IST
          const istNow = new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
          const istThen = new Date(then.getTime() + (5.5 * 60 * 60 * 1000));

          const diff = istNow - istThen;
          const seconds = Math.floor(diff / 1000);

          if (seconds < 60) return 'just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
          if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;

          return this.formatTime(date, true);
        } catch (e) {
          console.error('Relative time error:', e);
          return 'Unknown time';
        }
      },

      /**
       * Get current IST time
       * @returns {Date} Current time in IST
       */
      getCurrentIST() {
        const now = new Date();
        return new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
      },

      /**
       * Convert UTC to IST
       * @param {Date|string} date - UTC date to convert
       * @returns {Date} IST date
       */
      utcToIST(date) {
        if (!date) return null;
        const d = new Date(date);
        return new Date(d.getTime() + (5.5 * 60 * 60 * 1000));
      }
    };

    // Modified createDailyChart function
    function createDailyChart(dailyData) {
      try {
        const canvas = document.getElementById('dailyPatternChartCanvas');
        if (!canvas) {
          console.error('Daily chart canvas not found');
          return;
        }

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.error('Could not get daily chart context');
          return;
        }

        // Clean up existing chart
        if (window.chartInstances.daily) {
          window.chartInstances.daily.destroy();
        }

        const gradient = ctx.createLinearGradient(0, 0, 0, 300);
        gradient.addColorStop(0, 'rgba(79,70,229,0.4)');
        gradient.addColorStop(1, 'rgba(79,70,229,0.1)');

        const labels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const data = labels.map((_, i) => dailyData[i] || 0);

        window.chartInstances.daily = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              data,
              backgroundColor: gradient,
              borderColor: 'rgba(79,70,229,0.8)',
              borderWidth: 2,
              borderRadius: 6,
              barThickness: 'flex',
              maxBarThickness: 25
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: (context) => `${context.parsed.y} plays`
                },
                backgroundColor: 'rgba(15,23,42,0.9)',
                titleColor: '#f8fafc',
                bodyColor: '#94a3b8',
                borderColor: 'rgba(148,163,184,0.1)',
                borderWidth: 1,
                padding: 10,
                displayColors: false
              }
            },
            scales: {
              x: { grid: { display: false }, ticks: { color: '#94a3b8' } },
              y: {
                beginAtZero: true,
                grid: { color: 'rgba(148,163,184,0.1)', drawBorder: false },
                ticks: {
                  color: '#94a3b8',
                  callback: (value) => value % 1 === 0 ? value : ''
                }
              }
            }
          }
        });
      } catch (error) {
        console.error('Error creating daily chart:', error);
      }
    }

    // Modified createHourlyChart function
    function createHourlyChart(hourlyData) {
      try {
        const canvas = document.getElementById('hourlyPatternChartCanvas');
        if (!canvas) {
          console.error('Hourly chart canvas not found');
          return;
        }

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.error('Could not get hourly chart context');
          return;
        }

        // Clean up existing chart
        if (window.chartInstances.hourly) {
          window.chartInstances.hourly.destroy();
        }

        const gradient = ctx.createLinearGradient(0, 0, 0, 300);
        gradient.addColorStop(0, 'rgba(129,140,248,0.4)');
        gradient.addColorStop(1, 'rgba(129,140,248,0.1)');

        const labels = Array.from({ length: 24 }, (_, i) =>
          `${i.toString().padStart(2, '0')}:00`);
        const data = labels.map((_, i) => hourlyData[i] || 0);

        window.chartInstances.hourly = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [{
              data,
              backgroundColor: gradient,
              borderColor: 'rgba(129,140,248,0.8)',
              borderWidth: 2,
              tension: 0.4,
              fill: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false }
            },
            scales: {
              x: {
                grid: { display: false },
                ticks: {
                  color: '#94a3b8',
                  maxRotation: 45,
                  minRotation: 45,
                  callback: (_, index) => index % 3 === 0 ? labels[index] : ''
                }
              },
              y: {
                beginAtZero: true,
                grid: {
                  color: 'rgba(148,163,184,0.1)',
                  drawBorder: false
                }
              }
            }
          }
        });
      } catch (error) {
        console.error('Error creating hourly chart:', error);
      }
    }
    // Modified createPatternCharts function
    function createPatternCharts(patterns) {
      try {
        createDailyChart(patterns.daily);
        createHourlyChart(patterns.hourly);
      } catch (error) {
        console.error('Error creating pattern charts:', error);
      }
    }
    async function loadInsights() {
      try {
        const response = await fetch('/api/insights');
        const data = await response.json();

        // Helper function to safely update element text
        const setElementText = (id, value) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        };

        // Update basic stats
        setElementText('totalListeningTime', formatInsightDuration(data.overview.total_time));
        setElementText('totalSongs', data.overview.total_songs.toLocaleString());
        setElementText('uniqueArtists', data.overview.unique_artists.toLocaleString());
        setElementText('averageDaily', Math.round(data.overview.average_daily).toString());

        // Update top artists list
        const topArtistsList = document.getElementById('topArtistsList');
        if (topArtistsList && data.top_artists) {
          topArtistsList.innerHTML = data.top_artists.map((artist, index) => `
        <div class="artist-card fade-in" style="animation-delay: ${index * 0.1}s">
          <div class="artist-rank">#${index + 1}</div>
          <div class="artist-info">
            <div class="artist-name">${artist.name}</div>
            <div class="artist-stats">
              ${artist.plays.toLocaleString()} plays â€¢ ${formatInsightDuration(artist.time)}
            </div>
          </div>
        </div>
      `).join('');
        }

        // Initialize charts
        if (!window.Chart) {
          await loadScript('https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js');
        }

        // Create/update charts
        await initializeCharts();

        if (data.listening_patterns) {
          createPatternCharts(data.listening_patterns);
        }



        // Update recent activity
        if (data.recent_activity) {
          const recentActivityList = document.getElementById('recentActivityList');
          if (recentActivityList) {
            recentActivityList.innerHTML = data.recent_activity.map((activity, index) => `
          <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">

            <div class="activity-info">
              <div class="activity-title">${activity.title}</div>
              <div class="activity-artist">${activity.artist}</div>
            </div>
            <div class="activity-completion">
              <div class="completion-bar" style="width: ${activity.completion}%"></div>
            </div>
          </div>
        `).join('');
          }
        }

        // Update completion rate
        if (data.completion_rates?.average_completion) {
          setElementText('averageCompletion', `${data.completion_rates.average_completion.toFixed(1)}%`);
        }

      } catch (error) {
        console.error('Error loading insights:', error);
        showToast('Failed to load insights');
      }
    }
    function updateInsightElements(data) {
      // Helper function to safely update element text
      const setElementText = (id, value) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
      };

      // Helper for creating artist cards
      const createArtistCard = (artist, index) => `
    <div class="artist-card fade-in" style="animation-delay: ${index * 0.1}s">
      <div class="artist-rank">#${index + 1}</div>
      <div class="artist-info">
        <div class="artist-name">${artist.name}</div>
        <div class="artist-stats">
          ${artist.plays.toLocaleString()} plays â€¢ ${formatInsightDuration(artist.time)}
        </div>
      </div>
    </div>
  `;

      // Helper for creating activity items
      const createActivityItem = (activity, index) => `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${formatRelativeTime(new Date(activity.started_at))}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `;

      // Update overview stats
      setElementText('totalListeningTime', formatInsightDuration(data.overview.total_time));
      setElementText('totalSongs', data.overview.total_songs.toLocaleString());
      setElementText('uniqueArtists', data.overview.unique_artists.toLocaleString());
      setElementText('averageDaily', Math.round(data.overview.average_daily).toString());

      // Update top artists
      const topArtistsList = document.getElementById('topArtistsList');
      if (topArtistsList && data.top_artists) {
        topArtistsList.innerHTML = data.top_artists.map(createArtistCard).join('');
      }

      // Update recent activity
      const recentActivityList = document.getElementById('recentActivityList');
      if (recentActivityList && data.recent_activity) {
        recentActivityList.innerHTML = data.recent_activity.map(createActivityItem).join('');
      }

      // Update completion rate
      if (data.completion_rates?.average_completion) {
        setElementText('averageCompletion', `${data.completion_rates.average_completion.toFixed(1)}%`);
      }
    }
    function createActivityItem(activity, index) {
      const activityDate = new Date(activity.started_at);
      const formattedTime = formatRelativeTime(activityDate);

      return `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${formattedTime}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `;
    }

    let currentListenId = null;
    let currentSessionId = null;

    async function startListeningSession(songId, title, artist) {
      try {
        const response = await fetch('/api/listen/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ songId, title, artist })
        });
        const data = await response.json();
        currentListenId = data.listenId;
        currentSessionId = data.sessionId;
      } catch (error) {
        console.error('Failed to start listening session:', error);
      }
    }

    async function endListeningSession(duration, listenedDuration) {
      if (!currentListenId) return;

      try {
        await fetch('/api/listen/end', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            listenId: currentListenId,
            duration,
            listenedDuration
          })
        });
      } catch (error) {
        console.error('Failed to end listening session:', error);
      } finally {
        currentListenId = null;
      }
    }
  </script>
  <script>
    if ('mediaSession' in navigator) {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: '',
        artist: '',
        artwork: []
      });

      navigator.mediaSession.setActionHandler('play', () => {
        togglePlay();
      });
      navigator.mediaSession.setActionHandler('pause', () => {
        togglePlay();
      });
      navigator.mediaSession.setActionHandler('previoustrack', () => {
        playPrevious();
      });
      navigator.mediaSession.setActionHandler('nexttrack', () => {
        playNext();
      });
    }
    // Add history button to controls
    const historyButton = document.createElement('button');
    historyButton.className = 'control-button';
    historyButton.innerHTML = '<span class="material-icons">history</span>';
    historyButton.title = 'View History';
    document.querySelector('.player-controls').appendChild(historyButton);

    const historyModal = document.getElementById('historyModal');
    const closeHistory = document.getElementById('closeHistory');
    const historyList = document.getElementById('historyList');

    historyButton.addEventListener('click', () => {
      historyModal.style.display = 'block';
      loadHistory();
    });

    closeHistory.addEventListener('click', () => {
      historyModal.style.display = 'none';
    });
    class ImageLoader {
      constructor() {
        this.cache = new Map();
        this.corsEnabled = new Set();  // Track which domains support CORS
      }

      async loadImage(url, retryWithNoCors = true) {
        if (this.cache.has(url)) {
          return this.cache.get(url);
        }

        // For YouTube thumbnails, modify URL to use img.youtube.com
        if (url.includes('i.ytimg.com')) {
          url = url.replace('i.ytimg.com', 'img.youtube.com');
        }

        try {
          const imgUrl = await this.loadWithFallback(url, retryWithNoCors);
          this.cache.set(url, imgUrl);
          return imgUrl;
        } catch (error) {
          console.warn(`Failed to load image: ${url}`, error);
          return '/static/images/default-cover.png';
        }
      }

      async loadWithFallback(url, retryWithNoCors) {
        // Try loading with proxy first for known non-CORS domains
        if (!this.corsEnabled.has(new URL(url).hostname)) {
          try {
            const proxyUrl = `/api/proxy/image?url=${encodeURIComponent(url)}`;
            const response = await fetch(proxyUrl);
            if (response.ok) {
              const blob = await response.blob();
              return URL.createObjectURL(blob);
            }
          } catch (error) {
            console.warn('Proxy fetch failed, trying direct:', error);
          }
        }

        // Try direct load with CORS
        try {
          const response = await fetch(url, { mode: 'cors' });
          if (response.ok) {
            this.corsEnabled.add(new URL(url).hostname);
            const blob = await response.blob();
            return URL.createObjectURL(blob);
          }
        } catch (error) {
          console.warn('CORS fetch failed:', error);
        }

        // Last resort: return original URL for <img> to handle
        if (retryWithNoCors) {
          return url;
        }

        throw new Error('All image loading attempts failed');
      }
    }

    // Create a single instance for use throughout the app
    const imageLoader = new ImageLoader();
    // Update the ImageCache class with better CORS handling
    class ImageCache {
      constructor() {
        this.cache = new Map();
        this.retryCount = new Map();
        this.maxRetries = 4;
        this.initLocalStorage();
      }

      async loadImage(url, fallbackUrl = '/static/images/default-cover.png') {
        try {
          // First try memory cache
          if (this.cache.has(url)) {
            return this.cache.get(url);
          }

          // Then check localStorage cache
          const cacheData = JSON.parse(localStorage.getItem('imageCacheData') || '{}');
          if (cacheData[url] && Date.now() - cacheData[url].timestamp < 24 * 60 * 60 * 1000) {
            return cacheData[url].dataUrl;
          }

          // Try loading with CORS mode first
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.src = url;

          const imageData = await new Promise((resolve, reject) => {
            img.onload = () => {
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
              resolve(canvas.toDataURL('image/jpeg'));
            };
            img.onerror = () => reject(new Error('Image load failed'));
          });

          // Cache the successful result
          this.cache.set(url, imageData);
          cacheData[url] = {
            dataUrl: imageData,
            timestamp: Date.now()
          };
          localStorage.setItem('imageCacheData', JSON.stringify(cacheData));

          return imageData;

        } catch (error) {
          // If first attempt fails, try without CORS
          try {
            const response = await fetch(url, {
              mode: 'no-cors',
              cache: 'force-cache'
            });
            return url; // Return original URL if no-cors succeeds
          } catch (e) {
            console.warn(`Image load error for ${url}:`, e);
            return fallbackUrl;
          }
        }
      }

      initLocalStorage() {
        if (!localStorage.getItem('imageCacheData')) {
          localStorage.setItem('imageCacheData', JSON.stringify({}));
        }
        this.clearOldCache();
      }

      clearOldCache() {
        const cacheData = JSON.parse(localStorage.getItem('imageCacheData') || '{}');
        const now = Date.now();
        const oneDay = 24 * 60 * 60 * 1000;

        Object.keys(cacheData).forEach(key => {
          if (now - cacheData[key].timestamp > oneDay) {
            delete cacheData[key];
          }
        });

        localStorage.setItem('imageCacheData', JSON.stringify(cacheData));
      }

      blobToDataUrl(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }
    }
    let offset = 0;
    const limit = 5; // Load 5 items per scroll
    let isLoading = false;
    let observer = null; // Store observer to manage it properly

    //   async function loadHistory() {
    //     const historyList = document.getElementById('historyList');
    //     if (!historyList) return;

    //     // Clear any existing observer to prevent duplicate observers
    //     if (observer) {
    //       observer.disconnect();
    //     }

    //     // Reset offset and clear the list explicitly
    //     offset = 0;
    //     historyList.innerHTML = Array(5).fill(0).map(() => `
    //   <div class="history-item skeleton">
    //     <div class="history-thumbnail skeleton"></div>
    //     <div class="history-info skeleton"></div>
    //   </div>
    // `).join('');

    //     await loadMoreHistory();

    //     // Set up event delegation (only once)
    //     if (!historyList.dataset.listenerAdded) {
    //       historyList.addEventListener('click', (event) => {
    //         const historyItem = event.target.closest('.history-item');
    //         if (historyItem) {
    //           const songId = historyItem.dataset.id;
    //           loadAndPlay(songId);
    //           document.getElementById('historyModal').style.display = 'none';
    //         }
    //       });
    //       historyList.dataset.listenerAdded = 'true';
    //     }

    //     // Set up infinite scrolling
    //     const sentinel = document.createElement('div');
    //     sentinel.id = 'sentinel';
    //     historyList.appendChild(sentinel);

    //     observer = new IntersectionObserver(
    //       (entries) => {
    //         if (entries[0].isIntersecting && !isLoading) {
    //           loadMoreHistory();
    //         }
    //       },
    //       { rootMargin: '100px' }
    //     );
    //     observer.observe(sentinel);
    //   }


    // History loading state
    let historyOffset = 0;
    const historyLimit = 5; // Load 5 items per request
    let isHistoryLoading = false;
    let historyHasMore = true;
    let historyObserver = null;

    async function loadHistory() {
      const historyModal = document.getElementById('historyModal');
      const historyList = document.getElementById('historyList');
      if (!historyList) return;

      // Reset state
      historyOffset = 0;
      historyHasMore = true;
      historyList.innerHTML = '';

      // Show modal and initial skeletons
      historyModal.style.display = 'block';
      showHistorySkeletons(historyList);

      await loadMoreHistory(true);

      // Event delegation for play buttons
      historyList.addEventListener('click', (event) => {
        const historyItem = event.target.closest('.history-item');
        const playButton = event.target.closest('.history-play');
        if (historyItem && playButton) {
          const songId = historyItem.dataset.id;
          if (songId) {
            loadAndPlay(songId);
            historyModal.style.display = 'none';
          }
        }
      });

      // Setup Intersection Observer for infinite scroll
      setupHistoryObserver(historyList);
    }
    async function loadMoreHistory(initialLoad = false) {
      if (isHistoryLoading || !historyHasMore) return;
      isHistoryLoading = true;

      const historyList = document.getElementById('historyList');
      try {
        const response = await fetch(`/api/queue?limit=${historyLimit}&offset=${historyOffset}`);
        if (!response.ok) throw new Error('Failed to fetch history');
        const history = await response.json();

        if (initialLoad) {
          historyList.innerHTML = '';
        }

        if (history.length === 0) {
          historyHasMore = false;
          if (historyOffset === 0) {
            historyList.innerHTML = '<p>No history available</p>';
          }
          return;
        }

        const fragment = document.createDocumentFragment();
        history.forEach((item) => {
          const playedTime = TimeUtils.formatTime(item.played_at, true);
          const div = document.createElement('div');
          div.className = 'history-item';
          div.dataset.id = item.id;
          div.innerHTML = `
        <img class="history-thumbnail"
             src="${item.thumbnail || '/static/images/default-cover.png'}"
             alt="${item.title || 'Unknown Title'}"
             loading="lazy"
             onerror="this.src='/static/images/default-cover.png';">
        <div class="history-info">
          <div class="history-title">${item.title || 'Unknown Title'}</div>
          <div class="history-artist">${item.artist || 'Unknown Artist'}</div>
          <div class="history-time">${playedTime}</div>
        </div>
        <div class="history-play">
          <span class="material-icons">play_arrow</span>
        </div>
      `;
          fragment.appendChild(div);
        });

        historyList.appendChild(fragment);

        // Move the sentinel to the end after adding new items
        const sentinel = document.getElementById('history-sentinel');
        if (sentinel) {
          historyList.appendChild(sentinel);
        }

        historyOffset += history.length;
        historyHasMore = history.length === historyLimit;

      } catch (error) {
        console.error('Error loading history:', error);
        if (historyOffset === 0) {
          historyList.innerHTML = '<p>Failed to load history</p>';
        }
      } finally {
        isHistoryLoading = false;
      }
    }
    function showHistorySkeletons(container) {
      const fragment = document.createDocumentFragment();
      for (let i = 0; i < historyLimit; i++) {
        const div = document.createElement('div');
        div.className = 'history-item skeleton';
        div.innerHTML = `
      <div class="history-thumbnail skeleton"></div>
      <div class="history-info skeleton">
        <div class="history-title skeleton-loading" style="width: 70%; height: 16px;"></div>
        <div class="history-artist skeleton-loading" style="width: 50%; height: 14px; margin-top: 8px;"></div>
        <div class="history-time skeleton-loading" style="width: 30%; height: 12px; margin-top: 8px;"></div>
      </div>
      <div class="history-play skeleton-loading" style="width: 40px; height: 40px; border-radius: 50%;"></div>
    `;
        fragment.appendChild(div);
      }
      container.appendChild(fragment);
    }

    function setupHistoryObserver(historyList) {
      if (historyObserver) {
        historyObserver.disconnect();
      }

      const sentinel = document.createElement('div');
      sentinel.id = 'history-sentinel';
      historyList.appendChild(sentinel);

      historyObserver = new IntersectionObserver(
        (entries) => {
          if (entries[0].isIntersecting && !isHistoryLoading && historyHasMore) {
            loadMoreHistory();
          }
        },
        { rootMargin: '100px' }
      );
      historyObserver.observe(sentinel);
    }


    window.loadAndPlay = async function (songId) {
      await originalLoadAndPlay(songId);
      if (document.getElementById('historyModal').style.display === 'block') {
        loadHistory();
      }
    };

    const historyStyles = `
.history-error {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary);
}

.history-error .material-icons {
    font-size: 3rem;
    margin-bottom: 1rem;
    color: var(--error-color);
}

.history-item {
    display: flex;
    align-items: center;
    padding: 1rem;
    border-radius: 12px;
    margin-bottom: 1rem;
    background: var(--surface-color);
    transition: all 0.3s ease;
    cursor: pointer;
}

.history-item:hover {
    background: var(--card-color);
    transform: translateY(-2px);
}

.history-thumbnail {
    width: 60px;
    height: 60px;
    border-radius: 8px;
    margin-right: 1rem;
    object-fit: cover;
    background-color: var(--card-color);
}

.history-play {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--accent-gradient);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 1rem;
    opacity: 0;
    transition: all 0.3s ease;
}

.history-time {
    color: var(--text-secondary);
    font-size: 0.8rem;
    margin-top: 0.25rem;
}
`;

    // Add styles to document
    const styleSheet = document.createElement('style');
    styleSheet.textContent = historyStyles;
    document.head.appendChild(styleSheet);
    // Update chart initialization

    // Update createPatternCharts function with better error handling
    function createPatternCharts(patterns) {
      if (!patterns) return;

      const dailyCanvas = document.getElementById('dailyPatternChartCanvas');
      const hourlyCanvas = document.getElementById('hourlyPatternChartCanvas');

      if (dailyCanvas && patterns.daily) {
        createDailyChart(patterns.daily);
      }
      if (hourlyCanvas && patterns.hourly) {
        createHourlyChart(patterns.hourly);
      }
    }
    function createActivityItem(activity, index) {
      const timestamp = TimeUtils.formatRelativeTime(activity.started_at);

      return `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${timestamp}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `;
    }


    // Time formatting utilities
    const TimeFormatter = {
      /**
       * Format seconds to MM:SS or HH:MM:SS
       * @param {number} seconds - Time in seconds
       * @returns {string} Formatted time string
       */
      formatTime(seconds) {
        if (!seconds || isNaN(seconds)) {
          seconds = 0;
        }

        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);

        if (hours > 0) {
          return `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }
        return `${minutes}:${String(secs).padStart(2, '0')}`;
      },

      /**
       * Format time with IST timezone
       * @param {Date|string} date - Date to format
       * @param {boolean} includeDate - Whether to include date in output
       * @returns {string} Formatted time string
       */
      formatDateTime(date, includeDate = false) {
        if (!date) return '->';

        try {
          const d = new Date(date);
          // Convert to IST
          const istTime = new Date(d.getTime() + (5.5 * 60 * 60 * 1000));

          const options = {
            hour: 'numeric',
            minute: 'numeric',
            hour12: true,
            timeZone: 'Asia/Kolkata'
          };

          if (includeDate) {
            options.day = 'numeric';
            options.month = 'short';
            options.year = 'numeric';
          }

          return istTime.toLocaleString('en-IN', options);
        } catch (e) {
          console.error('Time formatting error:', e);
          return '->';
        }
      },

      /**
       * Format relative time in IST
       * @param {Date|string} date - Date to format
       * @returns {string} Relative time string
       */
      formatRelativeTime(date) {
        if (!date) return 'Unknown time';

        try {
          const now = new Date();
          const then = new Date(date);

          // Convert both to IST
          const istNow = new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
          const istThen = new Date(then.getTime() + (5.5 * 60 * 60 * 1000));

          const diff = istNow - istThen;
          const seconds = Math.floor(diff / 1000);

          if (seconds < 60) return 'just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
          if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;

          return this.formatDateTime(date, true);
        } catch (e) {
          console.error('Relative time error:', e);
          return 'Unknown time';
        }
      },

      /**
       * Format duration for insights
       * @param {number} seconds - Duration in seconds
       * @returns {string} Formatted duration string
       */
      formatDuration(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) {
          return `${days}d ${hours % 24}h`;
        } else if (hours > 0) {
          return `${hours}h ${minutes}m`;
        }
        return `${minutes}m`;
      }
    };

    // Make formatTime available globally
    window.formatTime = TimeFormatter.formatTime;
    window.formatDateTime = TimeFormatter.formatDateTime;
    window.formatRelativeTime = TimeFormatter.formatRelativeTime;
    window.formatDuration = TimeFormatter.formatDuration;
  </script>
  <script>
    // Add hover effect to music notes
    document.querySelectorAll('.music-note').forEach(note => {
      setInterval(() => {
        note.style.left = Math.random() * 80 + 10 + '%';
      }, 3000);
    });
  </script>
  <script>
    // Create a notification manager class
    class NotificationManager {
      constructor() {
        this.init();
      }

      init() {
        // Create container for notifications
        const container = document.createElement('div');
        container.className = 'notification-container';
        document.body.appendChild(container);

        // Add styles
        const styles = document.createElement('style');
        styles.textContent = `
      .notification-container {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 10px;
        max-width: 320px;
      }

      .notification {
        background: var(--surface-color);
        border-left: 4px solid;
        border-radius: 8px;
        padding: 16px;
        color: var(--text-primary);
        display: flex;
        align-items: flex-start;
        gap: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        transform-origin: left;
        animation: slideIn 0.3s ease forwards;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .notification.removing {
        animation: slideOut 0.3s ease forwards;
      }

      .notification:hover {
        transform: translateX(5px);
      }

      .notification-icon {
        font-size: 20px;
        flex-shrink: 0;
      }

      .notification-content {
        flex-grow: 1;
        padding-right: 20px;
      }

      .notification-title {
        font-weight: 600;
        margin-bottom: 4px;
      }

      .notification-message {
        font-size: 0.9rem;
        opacity: 0.9;
      }

      .notification-close {
        position: absolute;
        top: 8px;
        right: 8px;
        padding: 4px;
        border-radius: 50%;
        cursor: pointer;
        opacity: 0.6;
        transition: all 0.2s;
        background: none;
        border: none;
        color: inherit;
      }

      .notification-close:hover {
        opacity: 1;
        background: rgba(255,255,255,0.1);
      }

      .notification-progress {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 3px;
        background: rgba(255,255,255,0.1);
      }

      .notification-progress-bar {
        height: 100%;
        background: currentColor;
        transition: width linear;
      }

      /* Types */
      .notification.success {
        background: rgba(34,197,94,0.1);
        border-color: #22c55e;
        color: #22c55e;
      }

      .notification.error {
        background: rgba(239,68,68,0.1);
        border-color: #ef4444;
        color: #ef4444;
      }

      .notification.warning {
        background: rgba(234,179,8,0.1);
        border-color: #eab308;
        color: #eab308;
      }

      .notification.info {
        background: rgba(59,130,246,0.1);
        border-color: #3b82f6;
        color: #3b82f6;
      }

      @keyframes slideIn {
        from {
          transform: translateX(-100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(-100%);
          opacity: 0;
        }
      }
    `;
        document.head.appendChild(styles);
      }

      show({ title, message, type = 'info', duration = 5000 }) {
        const container = document.querySelector('.notification-container');
        const notification = document.createElement('div');

        // Set notification content
        notification.className = `notification ${type}`;
        notification.innerHTML = `
      <div class="notification-icon">
        <span class="material-icons">
          ${this.getIcon(type)}
        </span>
      </div>
      <div class="notification-content">
        <div class="notification-title">${title}</div>
        <div class="notification-message">${message}</div>
      </div>
      <button class="notification-close">
        <span class="material-icons">close</span>
      </button>
      <div class="notification-progress">
        <div class="notification-progress-bar"></div>
      </div>
    `;

        // Add to container
        container.appendChild(notification);

        // Setup progress bar
        const progressBar = notification.querySelector('.notification-progress-bar');
        progressBar.style.width = '100%';
        progressBar.style.transitionDuration = `${duration}ms`;

        // Start progress
        requestAnimationFrame(() => {
          progressBar.style.width = '0%';
        });

        // Setup close button
        const closeBtn = notification.querySelector('.notification-close');
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.remove(notification);
        });

        // Setup swipe to dismiss
        let startX = 0;
        let currentX = 0;

        notification.addEventListener('touchstart', (e) => {
          startX = e.touches[0].clientX;
        });

        notification.addEventListener('touchmove', (e) => {
          currentX = e.touches[0].clientX;
          const diff = currentX - startX;
          if (diff < 0) {
            notification.style.transform = `translateX(${diff}px)`;
          }
        });

        notification.addEventListener('touchend', () => {
          const diff = currentX - startX;
          if (diff < -100) {
            this.remove(notification);
          } else {
            notification.style.transform = '';
          }
        });

        // Auto remove after duration
        if (duration) {
          setTimeout(() => {
            if (container.contains(notification)) {
              this.remove(notification);
            }
          }, duration);
        }
      }

      remove(notification) {
        notification.classList.add('removing');
        setTimeout(() => {
          notification.remove();
        }, 300);
      }

      getIcon(type) {
        switch (type) {
          case 'success': return 'check_circle';
          case 'error': return 'error';
          case 'warning': return 'warning';
          case 'info': return 'info';
          default: return 'info';
        }
      }
    }

    // Create global instance
    window.notifications = new NotificationManager();

    // Usage examples:
    function showNotification(type, title, message, duration = 5000) {
      window.notifications.show({
        type,
        title,
        message,
        duration
      });
    }
    //usage
    // Show different types of notifications
    // showNotification('success', 'Success!', 'Operation completed successfully');
    // showNotification('error', 'Error!', 'Something went wrong');
    // showNotification('warning', 'Warning', 'Please backup before proceeding');
    // showNotification('info', 'Info', 'New update available');

    // // With custom duration (in milliseconds)
    // showNotification('info', 'Quick Note', 'This will disappear in 2 seconds', 2000);
  </script>
  <script>
    // Add enhanced progress loading styles
    const progressLoadingStyles = document.createElement('style');
    progressLoadingStyles.textContent = `
  /* Progress Skeleton Loading Styles */
  .progress-skeleton {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      90deg,
      var(--surface-color) 25%,
      var(--card-color) 50%,
      var(--surface-color) 75%
    );
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }

  /* Progress Bar Loading State */
  .progress-bar.loading {
    height: 12px;
    opacity: 0.3;
    transition: all 0.3s ease;
  }

  /* Progress Bar Loading Animation */
  @keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }

  /* Time Indicator Loading State */
  .time-indicator.loading {
    opacity: 0.5;
    animation: pulse 1.5s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 0.2; }
  }

  /* Mobile Specific Progress Bar Adjustments */
  @media (max-width: 768px) {
    .progress-bar.loading {
      height: 14px;
    }
  }
`;
    document.head.appendChild(progressLoadingStyles);

    // Enhanced progress loading management
    function enhanceProgressLoading() {
      const audio = E.audio;
      const miniProgress = E.progressBar;
      const fullProgress = E.fullProgressBar;
      const progressSkeleton = E.progressSkeleton;
      const timeIndicators = document.querySelectorAll('.time-indicator');
      const progressBars = document.querySelectorAll('.progress-bar');

      function showLoading() {
        progressSkeleton.style.opacity = "1";
        progressBars.forEach(bar => bar.classList.add('loading'));
        timeIndicators.forEach(indicator => indicator.classList.add('loading'));
      }

      function hideLoading() {
        progressSkeleton.style.opacity = "0";
        progressBars.forEach(bar => bar.classList.remove('loading'));
        timeIndicators.forEach(indicator => indicator.classList.remove('loading'));
      }

      // Show loading on audio events
      audio.addEventListener('loadstart', showLoading);
      audio.addEventListener('waiting', showLoading);
      audio.addEventListener('seeking', showLoading);
      audio.addEventListener('stalled', showLoading);

      // Hide loading when ready
      audio.addEventListener('canplay', hideLoading);
      audio.addEventListener('playing', hideLoading);
      audio.addEventListener('seeked', hideLoading);

      // Handle errors
      audio.addEventListener('error', () => {
        hideLoading();
        showToast('error', 'Playback Error', 'Failed to load audio. Please try again.');
      });

      // Modify setupInitialSong to show loading state immediately
      const originalSetupInitialSong = window.setupInitialSong;
      window.setupInitialSong = async function () {
        showLoading(); // Show loading immediately
        try {
          await originalSetupInitialSong.apply(this, arguments);
        } catch (error) {
          console.error('Setup initial song error:', error);
          hideLoading();
        }
      };

      // Show loading state initially if not ready
      if (audio.readyState < 3) {
        showLoading();
      }
    }

    // Initialize the enhanced progress loading
    document.addEventListener('DOMContentLoaded', enhanceProgressLoading);
  </script>
  <script>
    //  async function setFavicons() {
    //       const response = await fetch('/data/download/icons/sangeet-home');
    //       const data = await response.json();
    //       const base64Data = data.base64;

    //       const sizes = [16, 32, 48, 64, 128, 256];
    //       sizes.forEach(size => {
    //           const link = document.createElement('link');
    //           link.rel = 'icon';
    //           link.type = 'image/png';
    //           link.sizes = `${size}x${size}`;
    //           link.href = `data:image/png;base64,${base64Data}`;
    //           document.head.appendChild(link);
    //       });
    //   }

    //   // Call the function to set favicons
    //   setFavicons();
    // async function setGifFavicon() {
    //       const response = await fetch('/data/download/icons/sangeet-home'); // Adjust the route as needed
    //       const data = await response.json();
    //       const base64Gif = data.base64;

    //       // Define common sizes for favicons
    //       const sizes = [16, 32, 48, 64, 128, 256];

    //       // Clear any existing favicons
    //       const existingFavicons = document.querySelectorAll('link[rel="icon"]');
    //       existingFavicons.forEach(favicon => favicon.remove());

    //       // Add new favicons for each size
    //       sizes.forEach(size => {
    //           const link = document.createElement('link');
    //           link.rel = 'icon';
    //           link.type = 'image/gif';
    //           link.sizes = `${size}x${size}`;
    //           link.href = `data:image/gif;base64,${base64Gif}`;
    //           document.head.appendChild(link);
    //       });
    //   }

    //   // Call the function to set the GIF favicon
    //   setGifFavicon();
  </script>
  <script>

    // Enhanced progress bar touch handling
    function setupProgressBar(container, progressHover, callback) {
      if (!container || !progressHover) return;

      let isDragging = false;
      let touchStartX = 0;
      let lastUpdateTime = 0;
      const updateThreshold = 50; // Minimum time between updates in ms

      // Touch start handler
      container.addEventListener("touchstart", (e) => {
        e.preventDefault();
        isDragging = true;
        touchStartX = e.touches[0].clientX;

        // Show visual feedback
        container.querySelector('.progress-bar').style.height =
          window.innerWidth <= 768 ? '14px' : '12px';
      });

      // Enhanced touch move handler with throttling
      container.addEventListener("touchmove", (e) => {
        if (!isDragging) return;

        const currentTime = Date.now();
        if (currentTime - lastUpdateTime < updateThreshold) return;

        const touch = e.touches[0];
        const rect = container.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));

        progressHover.style.width = `${percent * 100}%`;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
          lastUpdateTime = currentTime;
        }
      }, { passive: false });

      // Touch end handler
      container.addEventListener("touchend", (e) => {
        isDragging = false;
        container.querySelector('.progress-bar').style.height =
          window.innerWidth <= 768 ? '10px' : '8px';
      });

      // Mouse handling with enhanced sensitivity
      container.addEventListener("mousedown", (e) => {
        isDragging = true;
        const rect = container.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
        }
      });

      container.addEventListener("mousemove", (e) => {
        const rect = container.getBoundingClientRect();
        const percent = ((e.clientX - rect.left) / rect.width) * 100;
        progressHover.style.width = `${percent}%`;

        if (isDragging && E.audio.duration) {
          E.audio.currentTime = E.audio.duration * (percent / 100);
        }
      });

      // Global mouse up handler
      document.addEventListener("mouseup", () => {
        isDragging = false;
      });

      // Prevent text selection while dragging
      container.addEventListener('selectstart', (e) => {
        if (isDragging) e.preventDefault();
      });
    }

    // Initialize enhanced progress bars
    document.addEventListener('DOMContentLoaded', () => {
      setupProgressBar(E.progressContainer, E.progressHover);
      setupProgressBar(E.fullProgressContainer, E.fullProgressHover);
    });
  </script>
  <script>
    /**
 * Session Management Enhancement
 */
    class SessionManager {
      constructor() {
        this.checkInterval = 10000; // Check every 10 seconds
        this.isCheckingSession = false;
        this.sessionInvalidated = false;
        this.initialize();
      }

      initialize() {
        // Start periodic checks
        this.startChecking();

        // Listen for visibility changes
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
            this.checkSessionStatus();
          }
        });

        // Check when user interacts after inactivity
        let lastActivity = Date.now();
        const activityEvents = ['mousedown', 'keydown', 'touchstart', 'click'];

        activityEvents.forEach(event => {
          document.addEventListener(event, () => {
            const now = Date.now();
            if (now - lastActivity > 30000) { // If inactive for 30s
              this.checkSessionStatus();
            }
            lastActivity = now;
          });
        });
      }

      async checkSessionStatus() {
        if (this.isCheckingSession || this.sessionInvalidated) return;

        this.isCheckingSession = true;

        try {
          const response = await fetch('/api/session-status');
          const data = await response.json();

          if (!response.ok || !data.valid) {
            this.sessionInvalidated = true;
            this.showSessionPopup(data.reason);
          }
        } catch (error) {
          console.error('Session check error:', error);
        } finally {
          this.isCheckingSession = false;
        }
      }

      startChecking() {
        setInterval(() => this.checkSessionStatus(), this.checkInterval);
      }

      showSessionPopup(reason) {
        // Stop all audio playback
        if (window.E && window.E.audio) {
          window.E.audio.pause();
        }

        // Create popup elements
        const overlay = document.createElement('div');
        overlay.className = 'session-popup-overlay';

        const popup = document.createElement('div');
        popup.className = 'session-popup';

        let title, message;
        switch (reason) {
          case 'logged_out_elsewhere':
            title = 'Session Ended';
            message = 'Your account has been logged in from another device. For security reasons, this session has been closed.';
            break;
          case 'expired':
            title = 'Session Expired';
            message = 'Your session has expired. Please log in again to continue.';
            break;
          default:
            title = 'Connection Lost';
            message = 'Your session is no longer active. Please log in again to continue.';
        }

        popup.innerHTML = `
      <div class="session-popup-icon">
        <span class="material-icons">error_outline</span>
      </div>
      <div class="session-popup-title">${title}</div>
      <div class="session-popup-message">${message}</div>
      <button class="session-popup-button">Login Again</button>
    `;

        // Add to document
        document.body.appendChild(overlay);
        document.body.appendChild(popup);

        // Handle button click
        const button = popup.querySelector('button');
        button.addEventListener('click', () => {
          window.location.href = '/login';
        });
      }
    }

    // Initialize session manager
    document.addEventListener('DOMContentLoaded', () => {
      window.sessionManager = new SessionManager();
    });
    class FestiveBackgroundSystem {
      constructor() {
        this.particleInterval = null;
        this.fps = 60;
        this.styles = `
      .bg-animation-wrapper {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        overflow: hidden;
        pointer-events: none;
      }

      .festive-background {
        position: absolute;
        inset: -50px;
        opacity: 0.3;
        background: linear-gradient(
          45deg,
          #ff9a9e,    /* Light pink */
          #fad0c4,    /* Peach */
          #a18cd1,    /* Light purple */
          #fbc2eb,    /* Pink */
          #ff5458,    /* Bright red */
          #ffc853,    /* Yellow */
          #70ff57,    /* Green */
          #45caff     /* Blue */
        );
        background-size: 800% 800%;
        animation:
          gradientFlow 30s ease infinite,
          colorPulse 15s ease-in-out infinite;
        filter: blur(100px);
      }

      .festive-background::after {
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(
          circle at center,
          transparent 0%,
          rgba(0, 0, 0, 0.2) 100%
        );
      }

      .festive-particle {
        position: fixed;
        pointer-events: none;
        width: 10px;
        height: 10px;
        background: white;
        border-radius: 50%;
        opacity: 0;
        z-index: -1;
        transform-origin: center;
        will-change: transform, opacity;
      }

      @keyframes gradientFlow {
        0% { background-position: 0% 0%; }
        25% { background-position: 100% 50%; }
        50% { background-position: 50% 100%; }
        75% { background-position: 0% 50%; }
        100% { background-position: 0% 0%; }
      }

      @keyframes colorPulse {
        0%, 100% { filter: blur(100px) hue-rotate(0deg); }
        25% { filter: blur(100px) hue-rotate(90deg); }
        50% { filter: blur(100px) hue-rotate(180deg); }
        75% { filter: blur(100px) hue-rotate(270deg); }
      }

      @keyframes particleFloat {
        0% {
          transform: translateY(0) rotate(0deg);
          opacity: 0;
        }
        20% { opacity: 0.8; }
        100% {
          transform: translateY(-100vh) rotate(360deg);
          opacity: 0;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .festive-background {
          animation: none;
          background-size: 100% 100%;
          background-position: center;
        }
        .festive-particle {
          display: none;
        }
      }
    `;

        this.colors = [
          '#FF5458', // Red (Gulal)
          '#FFC853', // Yellow (Turmeric)
          '#70FF57', // Green (Spring)
          '#45CAFF', // Blue (Sky)
          '#FF9A9E', // Pink
          '#FAD0C4', // Peach
          '#A18CD1', // Purple
          '#FBC2EB'  // Light pink
        ];

        this.init();
      }

      init() {
        this.injectStyles();
        this.createBackgroundElements();
        this.startParticleSystem();
        this.setupPerformanceMonitoring();
        this.handleVisibilityChange();
      }

      injectStyles() {
        const styleSheet = document.createElement('style');
        styleSheet.textContent = this.styles;
        document.head.appendChild(styleSheet);
      }

      createBackgroundElements() {
        const wrapper = document.createElement('div');
        wrapper.className = 'bg-animation-wrapper';

        const background = document.createElement('div');
        background.className = 'festive-background';

        wrapper.appendChild(background);
        document.body.appendChild(wrapper);
      }

      createParticle() {
        if (document.hidden) return;

        const particle = document.createElement('div');
        particle.className = 'festive-particle';

        // Random properties
        const size = Math.random() * 15 + 5;
        const left = Math.random() * 100;
        const duration = Math.random() * 2 + 2;
        const color = this.colors[Math.floor(Math.random() * this.colors.length)];

        particle.style.cssText = `
      left: ${left}vw;
      width: ${size}px;
      height: ${size}px;
      background: ${color};
      animation: particleFloat ${duration}s ease-in-out forwards;
      box-shadow: 0 0 ${size / 2}px rgba(255,255,255,0.5);
    `;

        document.body.appendChild(particle);

        // Clean up particle
        particle.addEventListener('animationend', () => {
          particle.remove();
        });
      }

      startParticleSystem() {
        const spawnParticles = () => {
          if (document.hidden) return;
          const count = this.fps > 30 ? 3 : 1;
          for (let i = 0; i < count; i++) {
            this.createParticle();
          }
        };

        this.particleInterval = setInterval(spawnParticles, 1000);
      }

      setupPerformanceMonitoring() {
        let frameCount = 0;
        let lastTime = performance.now();

        const checkPerformance = () => {
          frameCount++;
          const currentTime = performance.now();

          if (currentTime - lastTime >= 1000) {
            this.fps = frameCount;
            frameCount = 0;
            lastTime = currentTime;
          }

          requestAnimationFrame(checkPerformance);
        };

        requestAnimationFrame(checkPerformance);
      }

      handleVisibilityChange() {
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            clearInterval(this.particleInterval);
          } else {
            this.startParticleSystem();
          }
        });
      }
    }

    // Initialize the system when the DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      window.festiveBackground = new FestiveBackgroundSystem();
    });
  </script>
  <script>
    // Enhanced smooth seeking with both slide and tap support
    function initializeSmoothSeek() {
      const progressContainer = document.querySelector('.progress-container');
      const progressBar = document.querySelector('.progress-bar');
      const progress = document.querySelector('.progress');

      if (!progressContainer || !progressBar || !progress) return;

      let isDragging = false;
      let startX = 0;
      let startProgress = 0;

      // Touch event handlers
      progressContainer.addEventListener('touchstart', (e) => {
        isDragging = true;
        startX = e.touches[0].clientX;
        startProgress = progress.style.width ? parseInt(progress.style.width) : 0;

        // Get immediate seek position on tap
        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.touches[0].clientX - rect.left) / rect.width;
        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
          syncProgress();
        }
      }, { passive: true });

      progressContainer.addEventListener('touchmove', (e) => {
        if (!isDragging) return;

        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.touches[0].clientX - rect.left) / rect.width;
        const boundedPercent = Math.max(0, Math.min(1, percent));

        progress.style.width = `${boundedPercent * 100}%`;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * boundedPercent;
          syncProgress();
        }
      }, { passive: true });

      progressContainer.addEventListener('touchend', () => {
        isDragging = false;
      });

      // Mouse event handlers
      progressContainer.addEventListener('mousedown', (e) => {
        isDragging = true;
        startX = e.clientX;
        startProgress = progress.style.width ? parseInt(progress.style.width) : 0;

        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
          syncProgress();
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        const boundedPercent = Math.max(0, Math.min(1, percent));

        progress.style.width = `${boundedPercent * 100}%`;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * boundedPercent;
          syncProgress();
        }
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    }
    // Initialize
    document.addEventListener('DOMContentLoaded', initializeSmoothSeek);
  </script>
  <script>
    function formatTime(seconds) {
      if (!seconds || isNaN(seconds)) seconds = 0;
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      return hours > 0
        ? `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`
        : `${minutes}:${String(secs).padStart(2, '0')}`;
    }
  </script>
  <script>
    // Hamburger Menu HTML
    const hamburgerMenuHTML = `
<div class="hamburger-menu">
  <button class="hamburger-button">
    <span class="material-icons">menu</span>
  </button>
  <div class="menu-content">
    <div class="menu-header">
      <h3>Sangeet Premium Plus</h3>
      <button class="close-menu" style="
        padding: 0;
        background-color: #ff5f57;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        position: relative;
        &:hover {
          background-color: #ff7369;
        }
        &:active {
          background-color: #e04942;
          transform: scale(0.95);
        }
      ">
        <div style="
          width: 6px;
          height: 6px;
          background-color: rgba(0, 0, 0, 0.4);
          border-radius: 50%;
          transition: all 0.2s ease;
          position: absolute;
          &:hover {
            width: 8px;
            height: 2px;
            border-radius: 1px;
          }
        "></div>
      </button>
    </div>
    <div class="menu-items">
      <button class="menu-item" data-action="history">
        <span class="material-icons">history</span>
        <span>History</span>
      </button>
      <button class="menu-item" data-action="insights">
        <span class="material-icons">insights</span>
        <span>Insights</span>
      </button>
      <button class="menu-item" onclick="window.location.href='/logout'">
        <span class="material-icons">logout</span>
        <span>Logout</span>
      </button>
      <button class="menu-item" onclick="window.open('/get-extension', '_blank')">
        <span class="material-icons">get_app</span>
        <span>Get Extension</span>
      </button>
      <button class="menu-item" data-action="playlists">
        <span class="material-icons">playlist_play</span>
        <span>Playlists</span>
      </button>
      <button class="menu-item" data-action="report-issue">
        <span class="material-icons">report_problem</span>
        <span>Issues</span>
      </button>
      <a href="https://github.com/easy-ware/Sangeet-Premium-Plus-v3.0.0" target="_blank" class="glass-button">
        <svg class="source-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
        </svg>
        <span class="button-text">Get Source</span>
        <div class="sparkle" style="top: 20%; left: 10%"></div>
        <div class="sparkle" style="top: 60%; left: 80%"></div>
        <div class="sparkle" style="top: 30%; left: 60%"></div>
      </a>

      <div style="
        position: relative;
        text-align: center;
        min-height: 200px;
        overflow: hidden;
        padding: 20px;
        background: linear-gradient(135deg, #1e1e2f, #2d2d44);
      ">
        <h1 style="
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          color: white;
          background: linear-gradient(45deg, #ff3366, #ff6b6b);
          padding: 30px;
          border-radius: 15px;
          text-align: center;
          text-transform: uppercase;
          letter-spacing: 3px;
          text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
          position: relative;
          z-index: 1;
          transition: transform 0.3s ease;
        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
          Sangeet Premium Plus
          <span style="
            display: block;
            font-size: 16px;
            margin-top: 10px;
            font-weight: 300;
            text-transform: none;
            opacity: 0.9;
          ">Version V3.0.0</span>
        </h1>

        <!-- Animated Music Notes -->
        <div class="music-note" style="left: 10%; animation-delay: 0s;">â™ª</div>
        <div class="music-note" style="left: 20%; animation-delay: 0.5s;">â™«</div>
        <div class="music-note" style="right: 15%; animation-delay: 1s;">â™¬</div>
        <div class="music-note" style="right: 25%; animation-delay: 1.5s;">â™ª</div>
      </div>
    </div>
  </div>
</div>
`;

    // Hamburger Menu CSS
    const hamburgerStyles = `
.hamburger-menu {
  position: fixed;
  top: 1rem;
  left: 1rem;
  z-index: 1000;
}

.hamburger-button {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: var(--accent-gradient);
  border: none;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  transition: all 0.3s ease;
}

.hamburger-button:hover {
  transform: scale(1.1);
}

.menu-content {
  position: fixed;
  top: 0;
  right: -300px;
  width: 300px;
  height: 100vh;
  background: var(--surface-color);
  box-shadow: -5px 0 20px rgba(0,0,0,0.3);
  transition: right 0.3s ease;
  display: flex;
  flex-direction: column;
  overflow-y: scroll;
}

.menu-content::-webkit-scrollbar {
  width: 0;
}

.menu-content.active {
  right: 0;
}

.menu-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.menu-items {
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.menu-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  border-radius: 12px;
  background: none;
  border: none;
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.3s ease;
  width: 100%;
  text-align: left;
}

.menu-item:hover {
  background: var(--card-color);
  transform: translateX(5px);
}

.menu-item .material-icons {
  color: var(--primary-light);
}

/* Skeleton Loading Styles */
.skeleton-loading {
  animation: skeletonPulse 1.5s infinite;
  background: linear-gradient(90deg, var(--surface-color) 25%, var(--card-color) 50%, var(--surface-color) 75%);
  background-size: 200% 100%;
  border-radius: 8px;
}

@keyframes skeletonPulse {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}

.history-item.skeleton {
  opacity: 0.7;
}

.history-thumbnail.skeleton {
  background: var(--card-color);
}

.history-info.skeleton::before {
  content: '';
  display: block;
  width: 70%;
  height: 20px;
  background: var(--card-color);
  margin-bottom: 8px;
  border-radius: 4px;
}
  .playlist-list {
  max-height: 400px;
  overflow-y: auto;
  margin-top: 1rem;
}

.playlist-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem;
  background: var(--card-color);
  border-radius: 8px;
  margin-bottom: 0.5rem;
  cursor: pointer;
  transition: all 0.3s ease;
}

.playlist-item:hover {
  background: var(--surface-color);
  transform: translateY(-2px);
}

.playlist-item .playlist-info {
  flex-grow: 1;
}

.playlist-item .playlist-name {
  font-weight: 500;
  color: var(--text-primary);
}

.playlist-item .song-count {
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.playlist-actions {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.playlist-controls {
  display: flex;
  gap: 0.5rem;
}

.control-btn {
  background: none;
  border: none;
  color: var(--primary-light);
  cursor: pointer;
  padding: 0.5rem;
}

.control-btn:hover {
  color: var(--accent-color);
}

.song-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 1rem;
  background: var(--surface-color);
  border-radius: 4px;
  margin-bottom: 0.3rem;
}

.song-item:hover {
  background: var(--card-color);
}

.song-item .play-btn {
  display: none;
}

.song-item:hover .play-btn {
  display: block;
}
`;



    // Function to Initialize Hamburger Menu
    function initHamburgerMenu() {
      // Insert HTML
      document.body.insertAdjacentHTML('beforeend', hamburgerMenuHTML);

      // Add Styles
      const style = document.createElement('style');
      style.textContent = hamburgerStyles;
      document.head.appendChild(style);

      // Select Elements
      const hamburgerButton = document.querySelector('.hamburger-button');
      const menuContent = document.querySelector('.menu-content');
      const closeMenu = document.querySelector('.close-menu');

      // Verify Elements Exist
      if (!hamburgerButton || !menuContent || !closeMenu) {
        console.error('Hamburger menu elements not found:', {
          hamburgerButton,
          menuContent,
          closeMenu,
        });
        return;
      }

      // Toggle Menu Function
      const toggleMenu = () => {
        menuContent.classList.toggle('active');
      };

      // Close Menu Function
      const closeMenuFunc = () => {
        menuContent.classList.remove('active');
      };

      // Event Listeners
      hamburgerButton.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleMenu();
      });

      closeMenu.addEventListener('click', (e) => {
        e.stopPropagation();
        closeMenuFunc();
      });

      // Close on Outside Click
      document.addEventListener('click', (e) => {
        if (
          menuContent.classList.contains('active') &&
          !menuContent.contains(e.target) &&
          !hamburgerButton.contains(e.target)
        ) {
          closeMenuFunc();
        }
      });

      // Prevent Menu Close on Inside Click
      menuContent.addEventListener('click', (e) => {
        e.stopPropagation();
      });

      // Menu Item Actions
      document.querySelectorAll('.menu-item').forEach((item) => {
        item.addEventListener('click', () => {
          const action = item.dataset.action;
          closeMenuFunc();
          switch (action) {
            case 'history':
              document.getElementById('historyModal').style.display = 'block';
              loadHistory();
              break;
            case 'insights':
              document.getElementById('insightsModal').style.display = 'block';
              loadInsights();
              break;
            default:
              console.log(`Action ${action} not implemented`);
          }
        });
      });
    }

    // Ensure DOM is Loaded Before Initialization
    document.addEventListener('DOMContentLoaded', () => {
      initHamburgerMenu();
    });
  </script>
  <script>
    class PlaylistManager {
      constructor() {
        this.init();
      }

      /** Initialize elements and event listeners */
      init() {
        // Get DOM elements
        this.playlistModal = document.getElementById('playlistModal');
        this.closeButton = this.playlistModal.querySelector('.close-button');
        this.modalHeader = this.playlistModal.querySelector('#modalHeader');
        this.createPlaylistSection = this.playlistModal.querySelector('#createPlaylistSection');
        this.newPlaylistName = this.playlistModal.querySelector('#newPlaylistName');
        this.submitPlaylistBtn = this.playlistModal.querySelector('#submitPlaylistBtn');
        this.cancelPlaylistBtn = this.playlistModal.querySelector('#cancelPlaylistBtn');
        this.createPlaylistBtn = this.playlistModal.querySelector('#createPlaylistBtn');
        this.playlistList = this.playlistModal.querySelector('#playlistList');

        // Event listeners
        this.closeButton.addEventListener('click', () => {
          this.playlistModal.style.display = 'none';
        });

        this.createPlaylistBtn.addEventListener('click', () => {
          this.createPlaylistSection.style.display = 'block';
          this.createPlaylistBtn.style.display = 'none';
          this.newPlaylistName.focus();
        });

        this.cancelPlaylistBtn.addEventListener('click', () => {
          this.createPlaylistSection.style.display = 'none';
          this.createPlaylistBtn.style.display = 'block';
          this.newPlaylistName.value = '';
        });

        this.submitPlaylistBtn.addEventListener('click', () => this.createNewPlaylist());

        this.newPlaylistName.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') this.createNewPlaylist();
        });

        // Example triggers to open the modal
        document.querySelector('.menu-item[data-action="playlists"]').addEventListener('click', () => {
          this.openPlaylistModal(false);
        });

        document.getElementById('addToPlaylistButton').addEventListener('click', () => {
          this.openPlaylistModal(true);
        });
      }

      /** Open the playlist modal in view or add mode */
      async openPlaylistModal(isAddMode) {
        this.playlistModal.style.display = 'block';
        this.playlistList.innerHTML = '<div class="skeleton-loading" style="height: 50px;"></div>';

        if (isAddMode) {
          const songTitle = document.getElementById('fullPlayerTitle').textContent || 'Current Song';
          this.modalHeader.textContent = `Add "${songTitle}" to Playlist`;
        } else {
          this.modalHeader.textContent = 'Playlists';
        }

        try {
          const response = await fetch('/api/playlists');
          if (!response.ok) throw new Error('Failed to fetch playlists');
          const playlists = await response.json();

          this.playlistList.innerHTML = '';
          playlists.forEach(playlist => {
            const item = document.createElement('div');
            item.className = 'playlist-item';
            item.innerHTML = `
          <div class="playlist-info">
            <div class="playlist-name">${playlist.name}</div>
            <div class="song-count">${playlist.song_count} songs</div>
          </div>
          <div class="playlist-controls">
            ${isAddMode ?
                `<button class="control-btn add-to-playlist" data-playlist-id="${playlist.id}" title="Add to Playlist">
                <span class="material-icons">add</span>
              </button>` :
                `<button class="control-btn play-playlist" data-playlist-id="${playlist.id}" title="Play Playlist">
                <span class="material-icons">play_arrow</span>
              </button>
              <button class="control-btn shuffle-playlist" data-playlist-id="${playlist.id}" title="Shuffle Playlist">
                <span class="material-icons">shuffle</span>
              </button>
              <button class="control-btn share-playlist" data-playlist-id="${playlist.id}" title="Share Playlist">
                <span class="material-icons">share</span>
              </button>`}
          </div>
        `;
            this.playlistList.appendChild(item);

            if (isAddMode) {
              item.querySelector('.add-to-playlist').addEventListener('click', () => {
                this.addSongToPlaylist(playlist.id);
              });
            } else {
              item.addEventListener('click', () => this.showPlaylistSongs(playlist.id, playlist.name));
              item.querySelector('.play-playlist').addEventListener('click', (e) => {
                e.stopPropagation();
                this.playPlaylist(playlist.id, false);
              });
              item.querySelector('.shuffle-playlist').addEventListener('click', (e) => {
                e.stopPropagation();
                this.playPlaylist(playlist.id, true);
              });
              item.querySelector('.share-playlist').addEventListener('click', (e) => {
                e.stopPropagation();
                this.sharePlaylist(playlist.id);
              });
            }
          });
        } catch (error) {
          console.error('Error loading playlists:', error);
          this.playlistList.innerHTML = '<p>Failed to load playlists.</p>';
        }
      }

      /** Create a new playlist */
      async createNewPlaylist() {
        const name = this.newPlaylistName.value.trim();
        if (!name) {
          showToast('Please enter a playlist name', 'error');
          return;
        }

        try {
          const response = await fetch('/api/playlists/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name })
          });
          if (!response.ok) throw new Error('Failed to create playlist');
          showToast('Playlist created successfully!', 'success');
          this.createPlaylistSection.style.display = 'none';
          this.createPlaylistBtn.style.display = 'block';
          this.newPlaylistName.value = '';
          this.openPlaylistModal(false);
        } catch (error) {
          console.error('Error creating playlist:', error);
          showToast('Failed to create playlist', 'error');
        }
      }

      /** Add the current song to a playlist */
      async addSongToPlaylist(playlistId) {
        if (!state.currentSongId) {
          showToast('No song selected', 'error');
          return;
        }

        try {
          const response = await fetch('/api/playlists/add_song', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ playlist_id: playlistId, song_id: state.currentSongId })
          });
          if (!response.ok) throw new Error('Failed to add song');
          showToast('Song added to playlist!', 'success');
          this.playlistModal.style.display = 'none';
        } catch (error) {
          console.error('Error adding song to playlist:', error);
          showToast('Failed to add song', 'error');
        }
      }

      /** Display songs in a selected playlist */
      async showPlaylistSongs(playlistId, playlistName) {
        this.playlistList.innerHTML = '';

        const header = document.createElement('div');
        header.className = 'pl-header';
        header.innerHTML = `
      <button class="pl-back-btn"><span class="material-icons">arrow_back</span></button>
      <h3>${playlistName}</h3>
    `;
        this.playlistList.appendChild(header);

        header.querySelector('.pl-back-btn').addEventListener('click', () => {
          this.openPlaylistModal(false);
        });

        const skeleton = document.createElement('div');
        skeleton.className = 'skeleton-loading';
        skeleton.style.height = '50px';
        this.playlistList.appendChild(skeleton);

        try {
          const response = await fetch(`/api/playlists/${playlistId}/songs`);
          if (!response.ok) throw new Error('Failed to fetch playlist songs');
          const songs = await response.json();

          skeleton.remove();

          songs.forEach(song => {
            const songItem = document.createElement('div');
            songItem.className = 'pl-song-item';
            songItem.innerHTML = `
          <img src="${song.thumbnail || '/static/images/default-cover.png'}" alt="${song.title}" class="pl-song-thumb" loading="lazy">
          <div class="pl-song-info">
            <div class="pl-song-title">${song.title}</div>
            <div class="pl-song-artist">${song.artist}</div>
          </div>
          <button class="pl-control-btn pl-play-btn" data-song-id="${song.id}" title="Play Song">
            <span class="material-icons">play_arrow</span>
          </button>
        `;
            songItem.querySelector('.pl-play-btn').addEventListener('click', (e) => {
              e.stopPropagation();
              queueAndPlaySong(song.id);
            });
            this.playlistList.appendChild(songItem);
          });
        } catch (error) {
          console.error('Error loading playlist songs:', error);
          skeleton.remove();
          this.playlistList.innerHTML = '<p>Failed to load songs.</p>';
        }
      }

      /** Play a playlist, optionally shuffled */
      async playPlaylist(playlistId, shuffle) {
        try {
          const response = await fetch(`/api/playlists/${playlistId}/songs`);
          if (!response.ok) throw new Error('Failed to fetch playlist songs');
          const songs = await response.json();

          if (!songs.length) {
            showToast('Playlist is empty', 'warning');
            return;
          }

          state.queue = songs.map(song => song.id);
          state.queueIndex = -1;
          if (shuffle) {
            state.queue = state.queue.sort(() => Math.random() - 0.5);
          }
          playNext();
        } catch (error) {
          console.error('Error playing playlist:', error);
          showToast('Failed to play playlist', 'error');
        }
      }

      /** Share a playlist via Web Share API or clipboard */
      async sharePlaylist(playlistId) {
        try {
          const response = await fetch(`/api/playlists/${playlistId}/share`, { method: 'POST' });
          if (!response.ok) throw new Error('Failed to generate share link');
          const data = await response.json();
          const shareUrl = `${window.location.origin}/playlists/share/${data.share_id}`;

          if (navigator.share) {
            await navigator.share({
              title: 'Share Playlist',
              text: 'Check out my playlist!',
              url: shareUrl
            });
          } else {
            await navigator.clipboard.writeText(shareUrl);
            showToast('Playlist share link copied to clipboard!', 'success');
          }
        } catch (error) {
          console.error('Error sharing playlist:', error);
          showToast('Failed to share playlist', 'error');
        }
      }
    }

    // Initialize the playlist manager when the DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      new PlaylistManager();
    });
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Select DOM elements
      const fullPlayer = document.querySelector('.full-player');
      const fullPlayerContent = document.querySelector('.full-player-content');
      const minimizeButton = document.getElementById('minimizeButton');

      // Error handling: Check if required elements exist
      if (!fullPlayer || !fullPlayerContent) {
        console.error('Full player elements not found');
        return;
      }

      // Initialize variables
      let startY = 0;
      let currentY = 0;
      let isPulling = false;
      const threshold = window.innerHeight * 0.2; // 20% of screen height as threshold

      // Function to close the full player with animation
      function closeFullPlayer() {
        fullPlayer.style.transition = 'transform 0.4s ease, opacity 0.4s ease';
        fullPlayer.style.transform = 'translateY(100%)';
        fullPlayer.style.opacity = '0';
        setTimeout(() => {
          fullPlayer.classList.remove('active');
          fullPlayer.style.display = 'none';
          fullPlayer.style.transform = '';
          fullPlayer.style.opacity = '';
          fullPlayer.style.transition = '';
        }, 400); // Matches transition duration
      }

      // --- Touch Event Listeners for Mobile ---
      fullPlayer.addEventListener('touchstart', (e) => {
        // Only start pulling if content is at the top (or overscrolled)
        if (fullPlayerContent.scrollTop <= 0) {
          startY = e.touches[0].clientY;
          isPulling = true;
          fullPlayer.style.transition = ''; // Remove transition during pull
        }
      });

      fullPlayer.addEventListener('touchmove', (e) => {
        if (!isPulling) return;
        currentY = e.touches[0].clientY;
        const diff = currentY - startY;
        if (diff > 0) {
          // Translate player downward and adjust opacity for feedback
          fullPlayer.style.transform = `translateY(${diff}px)`;
          fullPlayer.style.opacity = Math.max(0.5, 1 - diff / (threshold * 2));
          e.preventDefault(); // Prevent pull-to-refresh or scrolling
        }
      }, { passive: false }); // Allow preventDefault()

      fullPlayer.addEventListener('touchend', () => {
        if (!isPulling) return;
        isPulling = false;
        const diff = currentY - startY;

        if (diff > threshold) {
          // Close the player if pulled beyond threshold
          closeFullPlayer();
        } else {
          // Snap back to original position
          fullPlayer.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
          fullPlayer.style.transform = 'translateY(0)';
          fullPlayer.style.opacity = '1';
          setTimeout(() => {
            fullPlayer.style.transition = '';
            fullPlayer.style.transform = '';
            fullPlayer.style.opacity = '';
          }, 300); // Matches snap-back duration
        }
      });

      // --- Mouse Event Listeners for Desktop ---
      fullPlayer.addEventListener('mousedown', (e) => {
        if (fullPlayerContent.scrollTop <= 0) {
          startY = e.clientY;
          isPulling = true;
          fullPlayer.style.transition = '';
        }
      });

      fullPlayer.addEventListener('mousemove', (e) => {
        if (!isPulling) return;
        currentY = e.clientY;
        const diff = currentY - startY;
        if (diff > 0) {
          fullPlayer.style.transform = `translateY(${diff}px)`;
          fullPlayer.style.opacity = Math.max(0.5, 1 - diff / (threshold * 2));
        }
      });

      document.addEventListener('mouseup', () => {
        if (!isPulling) return;
        isPulling = false;
        const diff = currentY - startY;

        if (diff > threshold) {
          closeFullPlayer();
        } else {
          fullPlayer.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
          fullPlayer.style.transform = 'translateY(0)';
          fullPlayer.style.opacity = '1';
          setTimeout(() => {
            fullPlayer.style.transition = '';
            fullPlayer.style.transform = '';
            fullPlayer.style.opacity = '';
          }, 300);
        }
      });

      // Attach close function to minimize button (if it exists)
      if (minimizeButton) {
        minimizeButton.addEventListener('click', closeFullPlayer);
      }
    });

    function openFullPlayer() {
      E.fullPlayer.style.display = 'flex';
      requestAnimationFrame(() => {
        E.fullPlayer.classList.add('active');
      });
    }

    E.expandButton.addEventListener('click', openFullPlayer);
  </script>
  <script>
    function createRipple(event) {
      const element = event.currentTarget;
      const ripple = document.createElement('span');
      ripple.classList.add('ripple');

      const rect = element.getBoundingClientRect();
      const x = (event.clientX || event.touches[0].clientX) - rect.left;
      const y = (event.clientY || event.touches[0].clientY) - rect.top;

      ripple.style.left = `${x}px`;
      ripple.style.top = `${y}px`;

      element.appendChild(ripple);

      setTimeout(() => {
        ripple.remove();
      }, 600);
    }

    document.querySelectorAll('.control-button, .song-card, .menu-item').forEach(el => {
      el.addEventListener('click', createRipple);
      el.addEventListener('touchstart', createRipple, { passive: true });
    });
  </script>
  <script>

    function checkProtocolAndShowWarning() {
      const overlay = document.getElementById('httpWarningOverlay');
      const closeButton = document.getElementById('httpWarningClose');
      const httpsLink = document.getElementById('httpsLink');

      // Function to show the warning
      function showWarning() {
        overlay.style.display = 'flex';
        const httpsUrl = `https://${window.location.hostname}${window.location.pathname}${window.location.search}`;
        httpsLink.href = httpsUrl;
        httpsLink.textContent = httpsUrl;

        // Auto-close after 10 seconds if still visible
        setTimeout(() => {
          if (overlay.style.display === 'flex') {
            overlay.style.display = 'none';
          }
        }, 10000);
      }

      // Function to hide the warning
      function hideWarning() {
        overlay.style.display = 'none';
      }

      // Attach close button listener once, outside the condition
      closeButton.addEventListener('click', hideWarning);

      // Check protocol and show warning if HTTP
      if (window.location.protocol !== 'https:') {
        showWarning();
      }
    }

    // Call the function when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', () => {
      checkProtocolAndShowWarning();
    });

  </script>
  <script>
  
/**
 * =========================================================================
 * Issue Reporting System - V3.1 (Complete Implementation)
 * -------------------------------------------------------------------------
 * Dynamically creates the modal HTML and links CSS.
 * Provides Report/My Issues tabs, detailed view with conversation.
 * Allows users to report issues and reply to admin comments.
 * Includes polling (5 seconds) for live updates in 'My Issues' and 'Detail' views.
 * Enhanced conversation bubble styling (requires corresponding CSS).
 * Corrected HTML escaping.
 * =========================================================================
 */
 (function() {
    // --- Module State ---
    let modal = null, closeButton = null, reportTabButton = null, myIssuesTabButton = null;
    let reportModalBody = null, reportFormView = null, myIssuesView = null, issueDetailView = null;
    let issuesLoading = null, issuesEmpty = null, issuesList = null;
    let issueDetailTitle = null, issueDetailContent = null, issueStatusBadge = null, issueStatusDate = null, backToIssuesButton = null;
    let reportTopicInput = null, reportDetailsInput = null, submitIssueButton = null;

    let currentView = 'report';
    let issuesLoaded = false;
    let selectedIssueId = null;
    let issuePollingIntervalId = null;
    const POLLING_INTERVAL_MS = 5000; // 5 seconds
    let lastIssueListDataHash = null;
    let lastIssueDetailDataHash = null;
    let isModalInitialized = false;
    const CSS_LINK_ID = 'reportIssueModalStyles';
    const CSS_PATH = '/design/report-issues'; // Path to your modal CSS

    // --- Initialization ---
    function init() {
        if (isModalInitialized) return;
        console.log("Initializing Issue Center...");

        createModalStructure(); // Creates base HTML in body
        updateDOMReferences();  // Finds the created elements by ID

        if (!modal) {
             console.error("Issue Reporting Modal root element not found after creation.");
             return; // Stop if creation failed
         }

        attachEventListeners(); // Add event handlers to the found elements
        ensureModalCSSLink(); // Links the external CSS file
        connectToHamburgerMenu(); // Links the trigger (e.g., menu button)

        isModalInitialized = true;
        console.log("Issue Center Initialized.");
    }

    // --- HTML Structure Creation ---
    function createModalStructure() {
        if (document.getElementById('reportIssueModal')) return;

        const modalContainer = document.createElement('div');
        modalContainer.id = 'reportIssueModal';
        modalContainer.className = 'report-issue-modal';
        modalContainer.setAttribute('aria-hidden', 'true'); // Initially hidden for accessibility
        modalContainer.setAttribute('role', 'dialog');
        modalContainer.setAttribute('aria-labelledby', 'issueCenterModalTitle');

        modalContainer.innerHTML = `
            <div class="report-modal-content" role="document">
                <div class="report-modal-header">
                    <h2 id="issueCenterModalTitle">Issue Center</h2>
                    <button class="report-close-button" id="reportCloseButton" aria-label="Close Issue Center">
                        <span class="material-icons">close</span>
                    </button>
                </div>
                <div class="report-tabs" role="tablist">
                    <button id="reportTabButton" class="report-tab active" data-view="report" role="tab" aria-selected="true" aria-controls="reportFormView">Report Issue</button>
                    <button id="myIssuesTabButton" class="report-tab" data-view="issues" role="tab" aria-selected="false" aria-controls="myIssuesView">My Issues</button>
                </div>
                <div class="report-modal-body" id="reportModalBody">
                    <!-- Views are added below -->
                </div>
            </div>`;
        document.body.appendChild(modalContainer);
        createViews(modalContainer.querySelector('#reportModalBody'));
    }

    function createViews(bodyElement) {
        if (!bodyElement) return;
        // Use innerHTML for simplicity, ensuring IDs match for updateDOMReferences
        bodyElement.innerHTML = `
             <!-- Report Issue Form View -->
             <div id="reportFormView" class="report-view active" role="tabpanel" aria-labelledby="reportTabButton">
                 <div class="report-form-group"><label for="reportTopic">Issue Topic</label><div class="report-input-container"><span class="report-input-icon material-icons">topic</span><input type="text" id="reportTopic" placeholder="Brief description..." autocomplete="off"></div></div>
                 <div class="report-form-group"><label for="reportDetails">Details</label><div class="report-input-container report-textarea-container"><span class="report-input-icon material-icons">description</span><textarea id="reportDetails" placeholder="Describe the issue..." rows="5"></textarea></div></div>
                 <div class="report-form-actions"><button id="submitIssueButton" class="report-primary-button"><span class="material-icons">send</span> Submit Issue</button></div>
             </div>
             <!-- My Issues List View -->
             <div id="myIssuesView" class="report-view" role="tabpanel" aria-labelledby="myIssuesTabButton">
                 <div class="issues-loading" id="issuesLoading" style="display: none;"><div class="loading-spinner"></div><p>Loading...</p></div>
                 <div class="issues-empty" id="issuesEmpty" style="display: none;"><span class="material-icons" style="font-size: 48px;">inbox</span><p>No issues reported yet.</p></div>
                 <div class="issues-list" id="issuesList" aria-live="polite"></div>
             </div>
             <!-- Issue Detail View -->
             <div id="issueDetailView" class="report-view">
                 <div class="issue-detail-header"><button id="backToIssuesButton" class="back-button" aria-label="Back to Issues List"><span class="material-icons">arrow_back</span></button><h3 id="issueDetailTitle">Issue Details</h3></div>
                 <div class="issue-detail-content" id="issueDetailContent"></div>
                 <div class="issue-detail-footer"><div class="issue-status" id="issueStatus"><span class="status-badge open" id="issueStatusBadge">Status</span><span class="status-date" id="issueStatusDate">Date</span></div></div>
             </div>
         `;
    }

    // --- Update DOM References ---
    function updateDOMReferences() {
        modal = document.getElementById('reportIssueModal');
        if (!modal) return;
        closeButton = modal.querySelector('#reportCloseButton');
        reportTabButton = modal.querySelector('#reportTabButton');
        myIssuesTabButton = modal.querySelector('#myIssuesTabButton');
        reportModalBody = modal.querySelector('#reportModalBody');
        reportFormView = modal.querySelector('#reportFormView');
        myIssuesView = modal.querySelector('#myIssuesView');
        issueDetailView = modal.querySelector('#issueDetailView');
        issuesLoading = modal.querySelector('#issuesLoading');
        issuesEmpty = modal.querySelector('#issuesEmpty');
        issuesList = modal.querySelector('#issuesList');
        issueDetailTitle = modal.querySelector('#issueDetailTitle');
        issueDetailContent = modal.querySelector('#issueDetailContent');
        issueStatusBadge = modal.querySelector('#issueStatusBadge');
        issueStatusDate = modal.querySelector('#issueStatusDate');
        backToIssuesButton = modal.querySelector('#backToIssuesButton');
        reportTopicInput = modal.querySelector('#reportTopic');
        reportDetailsInput = modal.querySelector('#reportDetails');
        submitIssueButton = modal.querySelector('#submitIssueButton');
    }

    // --- Attach Event Listeners ---
    function attachEventListeners() {
        if (!modal) return;
        closeButton?.addEventListener('click', closeModal);
        reportTabButton?.addEventListener('click', () => switchTab('report'));
        myIssuesTabButton?.addEventListener('click', () => switchTab('issues'));
        backToIssuesButton?.addEventListener('click', backToIssuesList);
        submitIssueButton?.addEventListener('click', submitIssue);
        modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && modal?.classList.contains('visible')) closeModal(); });
    }

     // --- Link CSS ---
     function ensureModalCSSLink() {
        if (document.getElementById(CSS_LINK_ID)) return;
        const link = document.createElement('link');
        link.id = CSS_LINK_ID;
        link.rel = 'stylesheet';
        link.href = CSS_PATH;
        document.head.appendChild(link);
        console.log("Linked Issue Modal CSS:", CSS_PATH);
     }


    // --- Core Modal/Tab Functions ---
    window.openIssueModal = function(tab = 'report') {
        if (!isModalInitialized) init();
        if (!modal) { console.error('Cannot open Issue Modal.'); return; }

        modal.classList.add('visible');
        modal.setAttribute('aria-hidden', 'false');

        // Set initial tab without transition animation glitch
        const reportView = getViewElement('report');
        const issuesView = getViewElement('issues');
        const detailView = getViewElement('detail');
        const isReportTab = tab === 'report';
        const isIssuesTab = tab === 'issues';
        reportView?.classList.toggle('active', isReportTab);
        issuesView?.classList.toggle('active', isIssuesTab);
        detailView?.classList.toggle('active', false); // Detail never opens first
        reportTabButton?.classList.toggle('active', isReportTab);
        myIssuesTabButton?.classList.toggle('active', isIssuesTab);
        reportTabButton?.setAttribute('aria-selected', isReportTab);
        myIssuesTabButton?.setAttribute('aria-selected', isIssuesTab);
        currentView = tab;

        if (tab === 'issues') {
            loadUserIssues().finally(() => startIssuePolling('list'));
        }
        reportModalBody?.scrollTo(0, 0); // Scroll to top on open
    };

    function closeModal() {
        if (!modal) return;
        modal.classList.remove('visible');
        modal.setAttribute('aria-hidden', 'true');
        stopIssuePolling();
        if (reportTopicInput) reportTopicInput.value = '';
        if (reportDetailsInput) reportDetailsInput.value = '';
        selectedIssueId = null;
        // Do not reset issuesLoaded here, preserve cache state
    }

    function switchTab(newTab) {
        if (!modal || newTab === currentView) return;
        stopIssuePolling();

        reportTabButton?.classList.toggle('active', newTab === 'report');
        myIssuesTabButton?.classList.toggle('active', newTab === 'issues');
        reportTabButton?.setAttribute('aria-selected', newTab === 'report');
        myIssuesTabButton?.setAttribute('aria-selected', newTab === 'issues');

        const oldViewElement = getViewElement(currentView);
        const newViewElement = getViewElement(newTab);
        const slideDirection = (newTab === 'report' || (currentView === 'detail' && newTab === 'issues')) ? 'right' : 'left';

        if (oldViewElement) animateViewTransition(oldViewElement, `slide-${slideDirection}`, false);
        if (newViewElement) animateViewTransition(newViewElement, `slide-${slideDirection === 'left' ? 'right' : 'left'}`, true);

        currentView = newTab;
        reportModalBody?.scrollTo(0, 0); // Scroll to top when switching tabs

        if (newTab === 'issues') {
            loadUserIssues(!issuesLoaded).finally(() => {
                if (modal?.classList.contains('visible') && currentView === 'issues') startIssuePolling('list');
            });
        }
    }

    function getViewElement(viewName) {
        if (!isModalInitialized) return null; // Don't try before init
        switch (viewName) {
            case 'report': return reportFormView;
            case 'issues': return myIssuesView;
            case 'detail': return issueDetailView;
            default: return null;
        }
    }

    function animateViewTransition(element, directionClass, isActivating) {
         if (!element) return;
         const activeClass = 'active';
         element.classList.remove('slide-left', 'slide-right');

         if (isActivating) {
             element.style.visibility = 'hidden'; // Hide before positioning
             element.classList.add(directionClass);
             element.classList.add(activeClass);
             requestAnimationFrame(() => { // Wait for classes to apply
                 element.style.visibility = 'visible';
                 requestAnimationFrame(() => { // Start animation
                    element.classList.remove(directionClass);
                 });
             });
         } else {
             element.classList.add(directionClass);
             const onEnd = () => {
                 element.classList.remove(activeClass);
                 element.classList.remove(directionClass);
                 element.style.visibility = 'hidden'; // Hide completely after animation
                 element.removeEventListener('transitionend', onEnd);
            };
             element.addEventListener('transitionend', onEnd, { once: true });
             setTimeout(() => { if (element.classList.contains(activeClass)) { onEnd(); } }, 400); // Fallback
         }
     }

    // --- Data Fetching and Display ---
     async function loadUserIssues(showLoadingIndicator = true) {
         const displaySpinner = showLoadingIndicator && !issuesLoaded;
         if (displaySpinner) {
             if(issuesLoading) issuesLoading.style.display = 'flex';
             if(issuesEmpty) issuesEmpty.style.display = 'none';
             if(issuesList) issuesList.innerHTML = '';
         }
        try {
             const response = await fetch('/api/user-issues');
             if (!response.ok) throw new Error('Failed fetch');
             const data = await response.json();
             issuesLoaded = true;
             const currentHash = generateIssueDataHash(data);
             if (currentHash !== lastIssueListDataHash || displaySpinner) { displayIssues(data); lastIssueListDataHash = currentHash; }
             return data;
         } catch (error) {
             console.error('Error loading issues:', error);
             if (displaySpinner) displayError();
             lastIssueListDataHash = null;
             throw error; // Re-throw for .finally if needed
         } finally {
             if (displaySpinner && issuesLoading) issuesLoading.style.display = 'none';
         }
     }

    function displayIssues(issues) {
        if (!issuesList || !issuesEmpty) return;
        issuesList.innerHTML = '';

        if (!issues || issues.length === 0) {
             issuesEmpty.style.display = 'flex';
             issuesEmpty.innerHTML = `<span class="material-icons" style="font-size: 48px; margin-bottom: 10px;">inbox</span><p>No issues reported yet.</p>`;
             return;
        }
        issuesEmpty.style.display = 'none';
        issues.sort((a, b) => new Date(b.updated_at) - new Date(a.created_at)); // Sort by most recently updated

        issues.forEach(issue => {
             const issueItem = document.createElement('button'); // Use button for accessibility
             issueItem.className = 'issue-item';
             issueItem.dataset.issueId = issue.id;
             issueItem.setAttribute('role', 'button');
             issueItem.setAttribute('aria-label', `View details for issue: ${issue.topic}`);
             const statusClass = issue.status.toLowerCase().replace(/\s+/g, '-');
             const hasUnread = issue.comments?.length > 0 && issue.comments[issue.comments.length - 1].is_admin; // Simplified unread check

             issueItem.innerHTML = `
                 <div class="issue-title ${hasUnread ? 'unread' : ''}">${escapeHtml(issue.topic)} ${hasUnread ? '<span class="unread-indicator">â€¢</span>':''}</div>
                 <div class="issue-meta">
                     <span class="issue-date">Updated: ${formatDate(issue.updated_at, true)}</span>
                     <span class="issue-status-badge ${statusClass}">${escapeHtml(issue.status)}</span>
                 </div>
            `;
             issueItem.addEventListener('click', () => viewIssueDetail(issue));
            issuesList.appendChild(issueItem);
        });
    }

     function viewIssueDetail(issue) {
        if (!issue || !issue.id || !isModalInitialized) { backToIssuesList(); return; }
        stopIssuePolling();
        selectedIssueId = issue.id;

        if (issueDetailTitle) issueDetailTitle.textContent = escapeHtml(issue.topic);
        if (!issueDetailContent) return;
        issueDetailContent.innerHTML = ''; // Clear previous

        const fragment = document.createDocumentFragment(); // Use fragment for performance

        // --- Original Description ---
        const descriptionBubble = document.createElement('div');
        descriptionBubble.className = 'conversation-bubble user-bubble';
        descriptionBubble.innerHTML = `<div class="bubble-header"><span class="bubble-author">You (Reported)</span><span class="bubble-date">${formatDate(issue.created_at, true)}</span></div><div class="bubble-content">${escapeHtml(issue.details || '')}</div>`;
        fragment.appendChild(descriptionBubble);

        // --- Discussion Section ---
        if (issue.comments && issue.comments.length > 0) {
             issue.comments.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
            issue.comments.forEach(comment => {
                 const isAdmin = comment.is_admin;
                 const authorLabel = isAdmin ? 'Sangeet Admin' : 'You';
                 const bubbleClass = isAdmin ? 'admin-bubble' : 'user-bubble';
                 const commentBubble = document.createElement('div');
                 commentBubble.className = `conversation-bubble ${bubbleClass}`;
                 commentBubble.innerHTML = `<div class="bubble-header"><span class="bubble-author">${escapeHtml(authorLabel)}</span><span class="bubble-date">${formatDate(comment.created_at, true)}</span></div><div class="bubble-content">${escapeHtml(comment.content)}</div>`;
                 fragment.appendChild(commentBubble);
            });
        } else {
             const noResponseP = document.createElement('p');
             noResponseP.className = 'no-responses';
             noResponseP.textContent = 'No further discussion yet.';
             fragment.appendChild(noResponseP);
        }

         // --- Reply Section (Conditional) ---
         if (issue.status !== 'Closed') {
            const replySection = document.createElement('div');
            replySection.className = 'user-reply-section';
            replySection.innerHTML = `<div class="report-input-container report-textarea-container"><textarea id="userReplyTextarea" placeholder="Type your reply..." rows="3" aria-label="Your reply"></textarea></div><div class="reply-actions"><button id="submitUserReplyButton" class="report-primary-button"><span class="material-icons">send</span> Send</button></div><div id="userReplyError" class="reply-error" aria-live="polite"></div>`;
            fragment.appendChild(replySection);
             // Attach listener after appending fragment
         } else {
             const closedNotice = document.createElement('div');
             closedNotice.className = 'user-reply-section issue-closed-notice';
             closedNotice.innerHTML = `<p><span class="material-icons">lock</span> Issue Closed. Replies disabled.</p>`;
             fragment.appendChild(closedNotice);
         }

        // Append fragment and attach listener
        issueDetailContent.appendChild(fragment);
         const submitReplyBtn = issueDetailContent.querySelector('#submitUserReplyButton');
         submitReplyBtn?.addEventListener('click', submitUserReply);

        // --- Update Status Footer ---
        if (issueStatusBadge) { issueStatusBadge.textContent = issue.status; issueStatusBadge.className = `status-badge ${issue.status.toLowerCase().replace(/\s+/g, '-')}`; }
        if (issueStatusDate) issueStatusDate.textContent = `Updated: ${formatDate(issue.updated_at, true)}`;

        // --- Switch View & Start Polling ---
        animateViewTransition(myIssuesView, 'slide-left', false);
        animateViewTransition(issueDetailView, 'slide-right', true);
        currentView = 'detail';
        lastIssueDetailDataHash = generateSingleIssueDataHash(issue);
        reportModalBody?.scrollTo({ top: reportModalBody.scrollHeight, behavior: 'smooth' }); // Scroll to bottom
        startIssuePolling('detail');
    }

    function backToIssuesList() {
        if (!isModalInitialized) return;
        stopIssuePolling();
        if (issueDetailView) animateViewTransition(issueDetailView, 'slide-right', false);
        if (myIssuesView) animateViewTransition(myIssuesView, 'slide-left', true);
        currentView = 'issues';
        selectedIssueId = null;
        lastIssueDetailDataHash = null;
        reportModalBody?.scrollTo(0, 0); // Scroll list to top
        // Refresh list and start polling
        loadUserIssues(false).finally(() => {
            if (modal?.classList.contains('visible') && currentView === 'issues') startIssuePolling('list');
        });
    }

    function displayError() {
        if (issuesEmpty) {
             issuesEmpty.style.display = 'flex';
             issuesEmpty.innerHTML = `<span class="material-icons" style="font-size: 48px;">error_outline</span><p>Failed to load issues.</p>`;
        }
        if (issuesList) issuesList.innerHTML = ''; // Clear any potential stale items
    }


    // --- Action Functions ---
    function submitIssue() {
        if (!reportTopicInput || !reportDetailsInput || !submitIssueButton) return;
        const topic = reportTopicInput.value.trim();
        const details = reportDetailsInput.value.trim();
        if (!topic || !details) { showToast('Topic and details required.', 'error'); return; }

        submitIssueButton.disabled = true; submitIssueButton.innerHTML = 'Submitting...';

        fetch('/api/report-issue', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ topic, details }) })
        .then(r => r.ok ? r.json() : r.json().then(e => Promise.reject(e)))
        .then(() => {
            reportTopicInput.value = ''; reportDetailsInput.value = '';
            showToast('Issue submitted!', 'success');
            issuesLoaded = false; switchTab('issues');
        })
        .catch(e => showToast(e.error || 'Failed to submit.', 'error'))
        .finally(() => { submitIssueButton.disabled = false; submitIssueButton.innerHTML = '<span class="material-icons">send</span> Submit'; });
    }

    function submitUserReply() {
         if (!selectedIssueId || !isModalInitialized) return;
         const textarea = modal.querySelector('#userReplyTextarea');
         const button = modal.querySelector('#submitUserReplyButton');
         const errorDiv = modal.querySelector('#userReplyError');
         const comment = textarea?.value.trim();

         if (!textarea || !button) { console.error("Reply elements not found in submitUserReply"); return; }
         if (errorDiv) errorDiv.textContent = '';
         if (!comment) { if(errorDiv) errorDiv.textContent = 'Reply cannot be empty.'; textarea.focus(); return; }

         button.disabled = true; button.innerHTML = 'Sending...';

         fetch(`/api/issues/${selectedIssueId}/reply`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ comment }) })
             .then(r => r.json().then(d => ({ ok: r.ok, data: d })))
             .then(({ ok, data }) => {
                 if (!ok) throw new Error(data.error || 'Failed');
                 textarea.value = ''; showToast('Reply sent!', 'success');
                 stopIssuePolling(); // Pause polling for manual refresh
                 return fetch('/api/user-issues'); // Re-fetch all issues to get the latest state
            })
             .then(res => res.ok ? res.json() : Promise.reject('Refetch failed'))
             .then(issues => {
                 const updatedIssue = issues.find(iss => iss.id == selectedIssueId);
                 if (updatedIssue && currentView === 'detail') {
                     viewIssueDetail(updatedIssue); // This restarts polling
                 } else { backToIssuesList(); }
             })
             .catch(error => {
                 console.error('Error sending/refreshing reply:', error);
                if (errorDiv) errorDiv.textContent = error.message === 'Failed refetch' ? 'Could not refresh view.' : (error.message || 'Send failed.');
                 showToast('Failed to send reply.', 'error');
                 if (currentView === 'detail' && !issuePollingIntervalId) startIssuePolling('detail'); // Resume polling if error occurred
             })
             .finally(() => {
                 if(button) { button.disabled = false; button.innerHTML = '<span class="material-icons">send</span> Send'; }
             });
    }


    // --- Polling Functions ---
     function generateIssueDataHash(issues) { if (!issues || !Array.isArray(issues)) return ''; try { return JSON.stringify(issues.map(iss => ({ i:iss.id, s:iss.status, u:iss.updated_at, cc:(iss.comments || []).length }))); } catch (e) { return `${Date.now()}`; } }
     function generateSingleIssueDataHash(issue) { if (!issue) return ''; try { const lc = issue.comments?.slice(-1)[0]?.created_at ?? ''; return JSON.stringify({ i:issue.id, s:issue.status, u:issue.updated_at, cc:(issue.comments || []).length, lc:lc }); } catch (e) { return `${Date.now()}`; } }

     function startIssuePolling(viewType) {
        stopIssuePolling();
         const pollFunction = async () => {
            if (!modal?.classList.contains('visible') || currentView !== viewType || !navigator.onLine) { stopIssuePolling(); return; }
            try {
                const r = await fetch('/api/user-issues'); if (!r.ok) return; const d = await r.json();
                 if (viewType === 'list') { const h=generateIssueDataHash(d); if(h !== lastIssueListDataHash){ lastIssueListDataHash=h; if(currentView === 'issues') displayIssues(d);}}
                else if (viewType === 'detail' && selectedIssueId) { const i=d.find(x=>x.id==selectedIssueId); if(i){const h=generateSingleIssueDataHash(i); if(h!==lastIssueDetailDataHash){lastIssueDetailDataHash=h; if(currentView==='detail') viewIssueDetail(i);}} else {showToast('Issue may have been closed or removed.','warning'); backToIssuesList();}}
            } catch(e) { console.error("Polling error:", e); } // Avoid stopping poll on temporary network errors
         };
         issuePollingIntervalId = setInterval(pollFunction, POLLING_INTERVAL_MS);
         console.log(`Polling started (${viewType}, ${issuePollingIntervalId})`);
        pollFunction(); // Run once immediately if modal is visible
     }

    function stopIssuePolling() {
        if (issuePollingIntervalId !== null) { clearInterval(issuePollingIntervalId); console.log(`Polling stopped (${issuePollingIntervalId})`); issuePollingIntervalId = null; }
    }

    // --- Utility Functions ---
    function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return unsafe ?? '';
        return unsafe
             .replace(/&/g, "&")
             .replace(/</g, "<")
             .replace(/>/g, ">")
             .replace(/"/g, '"')
             .replace(/'/g, "'"); // Correctly escape single quotes
    }
    function formatDate(dateString, includeTime = false) {
         if (!dateString) return '';
         try { const d = new Date(dateString); const opts = { year: 'numeric', month: 'short', day: 'numeric' }; if(includeTime) {opts.hour='numeric'; opts.minute='2-digit'; opts.hour12=true;} return d.toLocaleString('en-US', opts); } catch(e){ return 'Invalid Date'; }
     }
    function showToast(message, type = 'info') {
        if (typeof window.showNotification === 'function') window.showNotification(type, 'Issue Center', message);
        else console.log(`[Toast-${type}]: ${message}`);
     }
     function connectToHamburgerMenu() {
        const trigger = document.querySelector('[data-action="report-issue"], .report-issue-trigger');
        if (trigger) {
            const newTrigger = trigger.cloneNode(true);
            trigger.parentNode?.replaceChild(newTrigger, trigger);
            newTrigger.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); window.openIssueModal('report'); });
        } else { console.warn("Report Issue trigger not found."); }
    }

    // --- Auto-initialize ---
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init(); // Call directly if DOM is already loaded
    }
})();
  </script>

</body>

</html>
